{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: Not Quite Lisp ---\nSanta was hoping for a white Christmas, but his weather machine's \"snow\" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\n\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nHere's an easy puzzle to warm you up.\n\nSanta is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\n\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\n\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\n\nFor example:\n\n(()) and ()() both result in floor 0.\n((( and (()(()( both result in floor 3.\n))((((( also results in floor 3.\n()) and ))( both result in floor -1 (the first basement level).\n))) and )())()) both result in floor -3.\nTo what floor do the instructions take Santa?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Binary} = file:read_file(\"input.txt\"),\n    Instructions = binary_to_list(Binary),\n    Floor = lists:foldl(fun(X, Acc) -> if X == $( -> Acc + 1; true -> Acc - 1 end end, 0, Instructions),\n    io:format(\"~p~n\", [Floor]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 1: Not Quite Lisp ---\nSanta was hoping for a white Christmas, but his weather machine's \"snow\" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\n\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nHere's an easy puzzle to warm you up.\n\nSanta is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\n\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\n\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\n\nFor example:\n\n(()) and ()() both result in floor 0.\n((( and (()(()( both result in floor 3.\n))((((( also results in floor 3.\n()) and ))( both result in floor -1 (the first basement level).\n))) and )())()) both result in floor -3.\nTo what floor do the instructions take Santa?\n\nYour puzzle answer was 280.\n\n--- Part Two ---\nNow, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\n\nFor example:\n\n) causes him to enter the basement at character position 1.\n()()) causes him to enter the basement at character position 5.\nWhat is the position of the character that causes Santa to first enter the basement?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Instructions = binary_to_list(Data),\n    Answer = find_basement(Instructions, 0, 1),\n    io:format(\"~p\", [Answer]).\n\nfind_basement([], _Floor, _Position) ->\n    not_found; % In case the basement is never reached\nfind_basement([H|T], Floor, Position) ->\n    NewFloor = case H of\n        $( -> Floor + 1; % Increase floor if '('\n        $) -> Floor - 1  % Decrease floor if ')'\n    end,\n    if\n        NewFloor == -1 -> Position; % Return the position if basement is reached\n        true -> find_basement(T, NewFloor, Position + 1) % Otherwise, continue with the next character\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 2: I Was Told There Would Be No Math ---\nThe elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\n\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\n\nFor example:\n\nA present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet.\nA present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.\nAll numbers in the elves' list are in feet. How many total square feet of wrapping paper should they order?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Lines = string:split(binary_to_list(File), \"\\n\", all),\n    TotalArea = lists:foldl(fun(Present, Acc) ->\n        [L, W, H] = string:tokens(Present, \"x\"),\n        LNum = list_to_integer(L),\n        WNum = list_to_integer(W),\n        HNum = list_to_integer(H),\n        Side1 = LNum * WNum,\n        Side2 = WNum * HNum,\n        Side3 = HNum * LNum,\n        MinSide = lists:min([Side1, Side2, Side3]),\n        2*LNum*WNum + 2*WNum*HNum + 2*HNum*LNum + MinSide + Acc\n    end, 0, Lines),\n    io:format(\"~p~n\", [TotalArea]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 2: I Was Told There Would Be No Math ---\nThe elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\n\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\n\nFor example:\n\nA present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet.\nA present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.\nAll numbers in the elves' list are in feet. How many total square feet of wrapping paper should they order?\n\nYour puzzle answer was 1588178.\n\n--- Part Two ---\nThe elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\n\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don't ask how they tie the bow, though; they'll never tell.\n\nFor example:\n\nA present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for a total of 34 feet.\nA present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for a total of 14 feet.\nHow many total feet of ribbon should they order?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Input = string:tokens(binary_to_list(File), \"\\n\"),\n    Answer1 = lists:sum([calculate_wrapping_paper(X) || X <- Input]),\n    Answer2 = lists:sum([calculate_ribbon(X) || X <- Input]),\n    io:format(\"~p~n~p~n\", [Answer1, Answer2]).\n\ncalculate_wrapping_paper(Dimensions) ->\n    [L, W, H] = lists:map(fun(X) -> list_to_integer(X) end, string:tokens(Dimensions, \"x\")),\n    Sides = [L*W, W*H, H*L],\n    Area = 2*lists:sum(Sides) + lists:min(Sides),\n    Area.\n\ncalculate_ribbon(Dimensions) ->\n    [L, W, H] = lists:map(fun(X) -> list_to_integer(X) end, string:tokens(Dimensions, \"x\")),\n    SmallestPerimeter = lists:min([2*(L+W), 2*(W+H), 2*(H+L)]),\n    Volume = L*W*H,\n    Ribbon = SmallestPerimeter + Volume.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 3: Perfectly Spherical Houses in a Vacuum ---\nSanta is delivering presents to an infinite two-dimensional grid of houses.\n\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (>), or west (<). After each move, he delivers another present to the house at his new location.\n\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\n\nFor example:\n\n> delivers presents to 2 houses: one at the starting location, and one to the east.\n^>v< delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.\n^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Directions = binary_to_list(File),\n    Houses = move_houses([{0,0}], Directions),\n    Answer = length(lists:usort(Houses)),\n    io:format(\"~p~n\", [Answer]).\n\nmove_houses([{X,Y}|T], [Dir|Rest]) ->\n    NewPos = case Dir of\n                  $^ -> {X,Y+1};\n                  $v -> {X,Y-1};\n                  $> -> {X+1,Y};\n                  $< -> {X-1,Y}\n              end,\n    move_houses([NewPos|[{X,Y}|T]], Rest);\nmove_houses([{X,Y}|T], []) ->\n    [{X,Y}|T].\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 3: Perfectly Spherical Houses in a Vacuum ---\nSanta is delivering presents to an infinite two-dimensional grid of houses.\n\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (>), or west (<). After each move, he delivers another present to the house at his new location.\n\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\n\nFor example:\n\n> delivers presents to 2 houses: one at the starting location, and one to the east.\n^>v< delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.\n^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.\nYour puzzle answer was 2565.\n\n--- Part Two ---\nThe next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\n\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\n\nThis year, how many houses receive at least one present?\n\nFor example:\n\n^v delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south.\n^>v< now delivers presents to 3 houses, and Santa and Robo-Santa end up back where they started.\n^v^v^v^v^v now delivers presents to 11 houses, with Santa going one direction and Robo-Santa going the other.\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Instructions = binary_to_list(Data),\n    {SantaVisits, RoboSantaVisits} = deliver_presents(Instructions, {0, 0}, {0, 0}, [{0, 0}], true),\n    TotalVisits = lists:usort(SantaVisits ++ RoboSantaVisits),\n    Answer = length(TotalVisits),\n    io:format(\"~p~n\", [Answer]).\n\ndeliver_presents([], _SantaPos, _RoboSantaPos, Visits, _Turn) ->\n    {Visits, Visits};\ndeliver_presents([H|T], SantaPos, RoboSantaPos, Visits, Turn) ->\n    {NewSantaPos, NewRoboSantaPos, NewVisits} = case Turn of\n        true -> {move(H, SantaPos), RoboSantaPos, [move(H, SantaPos) | Visits]};\n        false -> {SantaPos, move(H, RoboSantaPos), [move(H, RoboSantaPos) | Visits]}\n    end,\n    deliver_presents(T, NewSantaPos, NewRoboSantaPos, NewVisits, not Turn).\n\nmove(Direction, {X, Y}) ->\n    case Direction of\n        $^ -> {X, Y + 1}; % North\n        $v -> {X, Y - 1}; % South\n        $> -> {X + 1, Y}; % East\n        $< -> {X - 1, Y}  % West\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 17: No Such Thing as Too Much ---\nThe elves bought too much eggnog again - 150 liters this time. To fit it all into your refrigerator, you'll need to move it into smaller containers. You take an inventory of the capacities of the available containers.\n\nFor example, suppose you have containers of size 20, 15, 10, 5, and 5 liters. If you need to store 25 liters, there are four ways to do it:\n\n15 and 10\n20 and 5 (the first 5)\n20 and 5 (the second 5)\n15, 5, and 5\nFilling all containers entirely, how many different combinations of containers can exactly fit all 150 liters of eggnog?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncount_combinations(Containers, Target, Index) when Target == 0 ->\n    1;\ncount_combinations(Containers, Target, Index) when Target < 0 orelse Index >= length(Containers) ->\n    0;\ncount_combinations(Containers, Target, Index) ->\n    count_combinations(Containers, Target - lists:nth(Index + 1, Containers), Index + 1) +\n    count_combinations(Containers, Target, Index + 1).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    Containers = read_file(File, []),\n    Answer = count_combinations(Containers, 150, 0),\n    io:format(\"~p~n\", [Answer]),\n    file:close(File).\n\nread_file(File, Acc) ->\n    case file:read_line(File) of\n        {ok, Data} ->\n            [Size | _] = string:tokens(Data, \"\\n\"),\n            SizeInt = list_to_integer(Size),\n            read_file(File, Acc ++ [SizeInt]);\n        eof ->\n            Acc\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: No Time for a Taxicab ---\nSanta's sleigh uses a very high-precision clock to guide its movements, and the clock's oscillator is regulated by stars. Unfortunately, the stars have been stolen... by the Easter Bunny. To save Christmas, Santa needs you to retrieve all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nYou're airdropped near Easter Bunny Headquarters in a city somewhere. \"Near\", unfortunately, is as close as you can get - the instructions on the Easter Bunny Recruiting Document the Elves intercepted start here, and nobody had time to work them out further.\n\nThe Document indicates that you should start at the given coordinates (where you just landed) and face North. Then, follow the provided sequence: either turn left (L) or right (R) 90 degrees, then walk forward the given number of blocks, ending at a new intersection.\n\nThere's no time to follow such ridiculous instructions on foot, though, so you take a moment and work out the destination. Given that you can only walk on the street grid of the city, how far is the shortest path to the destination?\n\nFor example:\n\nFollowing R2, L3 leaves you 2 blocks East and 3 blocks North, or 5 blocks away.\nR2, R2, R2 leaves you 2 blocks due South of your starting position, which is 2 blocks away.\nR5, L5, R5, R3 leaves you 12 blocks away.\nHow many blocks away is Easter Bunny HQ?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Instructions = binary:split(Data, <<\",\">>, [global, trim]),\n    {X, Y} = follow_instructions(Instructions, {0, 0}, north),\n    Answer = abs(X) + abs(Y),\n    io:format(\"~p~n\", [Answer]).\n\nfollow_instructions([], Pos, _Direction) ->\n    Pos;\nfollow_instructions([H|T], {X, Y}, Direction) ->\n    Instruction = binary_to_list(H),\n    [Turn|Rest] = string:trim(Instruction),\n    Steps = list_to_integer(Rest),\n    {NewDirection, DX, DY} = get_movement(Turn, Direction, Steps),\n    follow_instructions(T, {X + DX, Y + DY}, NewDirection).\n\nget_movement($L, north, Steps) -> {west, -Steps, 0};\nget_movement($R, north, Steps) -> {east, Steps, 0};\nget_movement($L, south, Steps) -> {east, Steps, 0};\nget_movement($R, south, Steps) -> {west, -Steps, 0};\nget_movement($L, east, Steps) -> {north, 0, Steps};\nget_movement($R, east, Steps) -> {south, 0, -Steps};\nget_movement($L, west, Steps) -> {south, 0, -Steps};\nget_movement($R, west, Steps) -> {north, 0, Steps}.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: Inverse Captcha ---\nThe night before Christmas, one of Santa's Elves calls you in a panic. \"The printer's broken! We can't print the Naughty or Nice List!\" By the time you make it to sub-basement 17, there are only a few minutes until midnight. \"We have a big problem,\" she says; \"there must be almost fifty bugs in this system, but nothing else can print The List. Stand in this square, quick! There's no time to explain; if you can convince them to pay you in stars, you'll be able to--\" She pulls a lever and the world goes blurry.\n\nWhen your eyes can focus again, everything seems a lot more pixelated than before. She must have sent you inside the computer! You check the system clock: 25 milliseconds until midnight. With that much time, you should be able to collect all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day millisecond in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nYou're standing in a room with \"digitization quarantine\" written in LEDs along one wall. The only door is locked, but it includes a small interface. \"Restricted Area - Strictly No Digitized Users Allowed.\"\n\nIt goes on to explain that you may only leave by solving a captcha to prove you're not a human. Apparently, you only get one millisecond to solve the captcha: too fast for a normal human, but it feels like hours to you.\n\nThe captcha requires you to review a sequence of digits (your puzzle input) and find the sum of all digits that match the next digit in the list. The list is circular, so the digit after the last digit is the first digit in the list.\n\nFor example:\n\n1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2) matches the fourth digit.\n1111 produces 4 because each digit (all 1) matches the next.\n1234 produces 0 because no digit matches the next.\n91212129 produces 9 because the only digit that matches the next one is the last digit, 9.\nWhat is the solution to your captcha?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Digits = binary_to_list(Data),\n    % Ensure we remove any newline character at the end of the input\n    CleanDigits = lists:filter(fun(X) -> X =/= $\\n end, Digits),\n    Answer = calculate_sum(CleanDigits),\n    io:format(\"~p~n\", [Answer]).\n\ncalculate_sum(Digits) ->\n    % Append the first element to the end to make the list circular\n    CircularDigits = Digits ++ [hd(Digits)],\n    calculate_sum(CircularDigits, 0).\n\ncalculate_sum([H, Next|T], Acc) when H == Next ->\n    calculate_sum([Next|T], Acc + (H - $0)); % $0 is the char code for '0', subtracting it converts char to int\ncalculate_sum([_H, Next|T], Acc) ->\n    calculate_sum([Next|T], Acc);\ncalculate_sum([_], Acc) ->\n    Acc.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 2: Corruption Checksum ---\nAs you walk through the door, a glowing humanoid shape yells in your direction. \"You there! Your state appears to be idle. Come help us repair the corruption in this spreadsheet - if we take another millisecond, we'll have to display an hourglass cursor!\"\n\nThe spreadsheet consists of rows of apparently-random numbers. To make sure the recovery process is on the right track, they need you to calculate the spreadsheet's checksum. For each row, determine the difference between the largest value and the smallest value; the checksum is the sum of all of these differences.\n\nFor example, given the following spreadsheet:\n\n5 1 9 5\n7 5 3\n2 4 6 8\nThe first row's largest and smallest values are 9 and 1, and their difference is 8.\nThe second row's largest and smallest values are 7 and 3, and their difference is 4.\nThe third row's difference is 6.\nIn this example, the spreadsheet's checksum would be 8 + 4 + 6 = 18.\n\nWhat is the checksum for the spreadsheet in your puzzle input?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Rows = string:tokens(binary_to_list(File), \"\\n\"),\n    Checksum = lists:foldl(fun(Row, Acc) -> Acc + row_checksum(lists:map(fun(X) -> list_to_integer(X) end, string:tokens(Row, \" \\t\\n\")), 0) end, 0, Rows),\n    io:format(\"~p~n\", [Checksum]).\n\nrow_checksum(Row, Acc) ->\n    Max = lists:max(Row),\n    Min = lists:min(Row),\n    Max - Min + Acc.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 4: High-Entropy Passphrases ---\nA new system policy has been put in place that requires all accounts to use a passphrase instead of simply a password. A passphrase consists of a series of words (lowercase letters) separated by spaces.\n\nTo ensure security, a valid passphrase must contain no duplicate words.\n\nFor example:\n\naa bb cc dd ee is valid.\naa bb cc dd aa is not valid - the word aa appears more than once.\naa bb cc dd aaa is valid - aa and aaa count as different words.\nThe system's full passphrase list is available as your puzzle input. How many passphrases are valid?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Passphrases = string:tokens(binary_to_list(File), \"\\n\"),\n    ValidPassphrases = lists:filter(fun(P) -> is_valid_passphrase(P) end, Passphrases),\n    io:format(\"~p~n\", [length(ValidPassphrases)]).\n\nis_valid_passphrase(Passphrase) ->\n    Words = string:tokens(Passphrase, \" \"),\n    length(Words) =:= length(lists:usort(Words)).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 4: High-Entropy Passphrases ---\nA new system policy has been put in place that requires all accounts to use a passphrase instead of simply a password. A passphrase consists of a series of words (lowercase letters) separated by spaces.\n\nTo ensure security, a valid passphrase must contain no duplicate words.\n\nFor example:\n\naa bb cc dd ee is valid.\naa bb cc dd aa is not valid - the word aa appears more than once.\naa bb cc dd aaa is valid - aa and aaa count as different words.\nThe system's full passphrase list is available as your puzzle input. How many passphrases are valid?\n\nYour puzzle answer was 451.\n\n--- Part Two ---\nFor added security, yet another system policy has been put in place. Now, a valid passphrase must contain no two words that are anagrams of each other - that is, a passphrase is invalid if any word's letters can be rearranged to form any other word in the passphrase.\n\nFor example:\n\nabcde fghij is a valid passphrase.\nabcde xyz ecdab is not valid - the letters from the third word can be rearranged to form the first word.\na ab abc abd abf abj is a valid passphrase, because all letters need to be used when forming another word.\niiii oiii ooii oooi oooo is valid.\noiii ioii iioi iiio is not valid - any of these words can be rearranged to form any other word.\nUnder this new system policy, how many passphrases are valid?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Passphrases = string:tokens(binary_to_list(Data), \"\\n\"),\n    ValidCount = lists:foldl(fun(Passphrase, Acc) ->\n        Words = string:tokens(Passphrase, \" \"),\n        WordSet = lists:foldl(fun(Word, {Set, Valid}) ->\n            SortedWord = lists:sort(Word),\n            case sets:is_element(SortedWord, Set) of\n                true -> {Set, false};\n                false -> {sets:add_element(SortedWord, Set), Valid}\n            end\n        end, {sets:new(), true}, Words),\n        case element(2, WordSet) of\n            true -> Acc + 1;\n            false -> Acc\n        end\n    end, 0, Passphrases),\n    io:format(\"~p~n\", [ValidCount]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 5: A Maze of Twisty Trampolines, All Alike ---\nAn urgent interrupt arrives from the CPU: it's trapped in a maze of jump instructions, and it would like assistance from any programs with spare cycles to help find the exit.\n\nThe message includes a list of the offsets for each jump. Jumps are relative: -1 moves to the previous instruction, and 2 skips the next one. Start at the first instruction in the list. The goal is to follow the jumps until one leads outside the list.\n\nIn addition, these instructions are a little strange; after each jump, the offset of that instruction increases by 1. So, if you come across an offset of 3, you would move three instructions forward, but change it to a 4 for the next time it is encountered.\n\nFor example, consider the following list of jump offsets:\n\n0\n3\n0\n1\n-3\nPositive jumps (\"forward\") move downward; negative jumps move upward. For legibility in this example, these offset values will be written all on one line, with the current instruction marked in parentheses. The following steps would be taken before an exit is found:\n\n(0) 3  0  1  -3  - before we have taken any steps.\n(1) 3  0  1  -3  - jump with offset 0 (that is, don't jump at all). Fortunately, the instruction is then incremented to 1.\n2 (3) 0  1  -3  - step forward because of the instruction we just modified. The first instruction is incremented again, now to 2.\n2  4  0  1 (-3) - jump all the way to the end; leave a 4 behind.\n2 (4) 0  1  -2  - go back to where we just were; increment -3 to -2.\n2  5  0  1  -2  - jump 4 steps forward, escaping the maze.\nIn this example, the exit is reached in 5 steps.\n\nHow many steps does it take to reach the exit?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\nparse_input() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    [list_to_integer(X) || X <- string:split(binary_to_list(File), \"\\n\",all)].\n\njump(Instructions, Index, Steps) when Index < 1 orelse Index > length(Instructions) ->\n    Steps;\njump(Instructions, Index, Steps) ->\n    NextIndex = Index + lists:nth(Index, Instructions),\n    NewInstructions = lists:sublist(Instructions, Index-1) ++ [lists:nth(Index, Instructions) + 1] ++ lists:nthtail(Index, Instructions),\n    jump(NewInstructions, NextIndex, Steps + 1).\n\ncall() ->\n    Instructions = parse_input(),\n    io:format(\"~p~n\", [jump(Instructions, 1, 0)]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 15: Dueling Generators ---\nHere, you encounter a pair of dueling generators. The generators, called generator A and generator B, are trying to agree on a sequence of numbers. However, one of them is malfunctioning, and so the sequences don't always match.\n\nAs they do this, a judge waits for each of them to generate its next value, compares the lowest 16 bits of both values, and keeps track of the number of times those parts of the values match.\n\nThe generators both work on the same principle. To create its next value, a generator will take the previous value it produced, multiply it by a factor (generator A uses 16807; generator B uses 48271), and then keep the remainder of dividing that resulting product by 2147483647. That final remainder is the value it produces next.\n\nTo calculate each generator's first value, it instead uses a specific starting value as its \"previous value\" (as listed in your puzzle input).\n\nFor example, suppose that for starting values, generator A uses 65, while generator B uses 8921. Then, the first five pairs of generated values are:\n\n--Gen. A--  --Gen. B--\n  1092455   430625591\n1181022009  1233683848\n245556042  1431495498\n1744312007   137874439\n1352636452   285222916\nIn binary, these pairs are (with generator A's value first in each pair):\n\n00000000000100001010101101100111\n00011001101010101101001100110111\n\n01000110011001001111011100111001\n01001001100010001000010110001000\n\n00001110101000101110001101001010\n01010101010100101110001101001010\n\n01100111111110000001011011000111\n00001000001101111100110000000111\n\n01010000100111111001100000100100\n00010001000000000010100000000100\nHere, you can see that the lowest (here, rightmost) 16 bits of the third value match: 1110001101001010. Because of this one match, after processing these five pairs, the judge would have added only 1 to its total.\n\nTo get a significant sample, the judge would like to consider 40 million pairs. (In the example above, the judge would eventually find a total of 588 pairs that match in their lowest 16 bits.)\n\nAfter 40 million pairs, what is the judge's final count?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {StartA, StartB} = read_input(\"input.txt\"),\n    Count = count_matching_pairs(StartA, StartB, 40000000),\n    io:format(\"~p~n\", [Count]).\n\nread_input(FileName) ->\n    {ok, File} = file:read_file(FileName),\n    [StartA, StartB] = lists:map(fun(X) -> list_to_integer(X) end, string:tokens(binary_to_list(File), \"\\r\\n\")),\n    {StartA, StartB}.\n\ncount_matching_pairs(StartA, StartB, 0) ->\n    0;\ncount_matching_pairs(StartA, StartB, N) ->\n    NextA = generate_next(StartA, 16807),\n    NextB = generate_next(StartB, 48271),\n    Count = if NextA band 65535 == NextB band 65535 -> 1; true -> 0 end,\n    count_matching_pairs(NextA, NextB, N-1) + Count.\n\ngenerate_next(Prev, Factor) ->\n    (Prev * Factor rem 2147483647).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 23: Coprocessor Conflagration ---\nYou decide to head directly to the CPU and fix the printer from there. As you get close, you find an experimental coprocessor doing so much work that the local programs are afraid it will halt and catch fire. This would cause serious issues for the rest of the computer, so you head in and see what you can do.\n\nThe code it's running seems to be a variant of the kind you saw recently on that tablet. The general functionality seems very similar, but some of the instructions are different:\n\nset X Y sets register X to the value of Y.\nsub X Y decreases register X by the value of Y.\nmul X Y sets register X to the result of multiplying the value contained in register X by the value of Y.\njnz X Y jumps with an offset of the value of Y, but only if the value of X is not zero. (An offset of 2 skips the next instruction, an offset of -1 jumps to the previous instruction, and so on.)\nOnly the instructions listed above are used. The eight registers here, named a through h, all start at 0.\n\nThe coprocessor is currently set to some kind of debug mode, which allows for testing, but prevents it from doing any meaningful work.\n\nIf you run the program (your puzzle input), how many times is the mul instruction invoked?\n\nYour puzzle answer was 3025.\n\n--- Part Two ---\nNow, it's time to fix the problem.\n\nThe debug mode switch is wired directly to register a. You flip the switch, which makes register a now start at 1 when the program is executed.\n\nImmediately, the coprocessor begins to overheat. Whoever wrote this program obviously didn't choose a very efficient implementation. You'll need to optimize the program if it has any hope of completing before Santa needs that printer working.\n\nThe coprocessor's ultimate goal is to determine the final value left in register h once the program completes. Technically, if it had that... it wouldn't even need to run the program.\n\nAfter setting register a to 1, if the program were to run to completion, what value would be left in register h?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\nis_prime(N) -> \n    is_prime(N, 2).\nis_prime(N, I) when I*I =< N -> \n    case N rem I of\n        0 -> false;\n        _ -> is_prime(N, I+1)\n    end;\nis_prime(_N, _I) -> \n    true.\n\ncall() ->\n    B = 57*100 + 100000,\n    C = B + 17000,\n    H = count_primes(B, C, 0),\n    io:format(\"~p~n\", [H]).\n\ncount_primes(B, C, H) when B =< C -> \n    NewH = case is_prime(B) of\n                true -> H;\n                false -> H + 1\n           end,\n    count_primes(B+17, C, NewH);\ncount_primes(_B, _C, H) -> \n    H.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: Chronal Calibration ---\n\"We've detected some temporal anomalies,\" one of Santa's Elves at the Temporal Anomaly Research and Detection Instrument Station tells you. She sounded pretty worried when she called you down here. \"At 500-year intervals into the past, someone has been changing Santa's history!\"\n\n\"The good news is that the changes won't propagate to our time stream for another 25 days, and we have a device\" - she attaches something to your wrist - \"that will let you fix the changes with no such propagation delay. It's configured to send you 500 years further into the past every few days; that was the best we could do on such short notice.\"\n\n\"The bad news is that we are detecting roughly fifty anomalies throughout time; the device will indicate fixed anomalies with stars. The other bad news is that we only have one device and you're the best person for the job! Good lu--\" She taps a button on the device and you suddenly feel like you're falling. To save Christmas, you need to get all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nAfter feeling like you've been falling for a few minutes, you look at the device's tiny screen. \"Error: Device must be calibrated before first use. Frequency drift detected. Cannot maintain destination lock.\" Below the message, the device shows a sequence of changes in frequency (your puzzle input). A value like +6 means the current frequency increases by 6; a value like -3 means the current frequency decreases by 3.\n\nFor example, if the device displays frequency changes of +1, -2, +3, +1, then starting from a frequency of zero, the following changes would occur:\n\nCurrent frequency  0, change of +1; resulting frequency  1.\nCurrent frequency  1, change of -2; resulting frequency -1.\nCurrent frequency -1, change of +3; resulting frequency  2.\nCurrent frequency  2, change of +1; resulting frequency  3.\nIn this example, the resulting frequency is 3.\n\nHere are other example situations:\n\n+1, +1, +1 results in  3\n+1, +1, -2 results in  0\n-1, -2, -3 results in -6\nStarting with a frequency of zero, what is the resulting frequency after all of the changes in frequency have been applied?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Input = binary_to_list(File),\n    Frequencies = string:split(Input, \"\\n\", all),\n    Result = lists:sum(lists:map(fun(X) -> list_to_integer(string:strip(X)) end, Frequencies)),\n    io:format(\"~p~n\", [Result]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 8: Memory Maneuver ---\nThe sleigh is much easier to pull than you'd expect for something its weight. Unfortunately, neither you nor the Elves know which way the North Pole is from here.\n\nYou check your wrist device for anything that might help. It seems to have some kind of navigation system! Activating the navigation system produces more bad news: \"Failed to start navigation system. Could not read software license file.\"\n\nThe navigation system's license file consists of a list of numbers (your puzzle input). The numbers define a data structure which, when processed, produces some kind of tree that can be used to calculate the license number.\n\nThe tree is made up of nodes; a single, outermost node forms the tree's root, and it contains all other nodes in the tree (or contains nodes that contain nodes, and so on).\n\nSpecifically, a node consists of:\n\nA header, which is always exactly two numbers:\nThe quantity of child nodes.\nThe quantity of metadata entries.\nZero or more child nodes (as specified in the header).\nOne or more metadata entries (as specified in the header).\nEach child node is itself a node that has its own header, child nodes, and metadata. For example:\n\n2 3 0 3 10 11 12 1 1 0 1 99 2 1 1 2\nA----------------------------------\n    B----------- C-----------\n                     D-----\nIn this example, each node of the tree is also marked with an underline starting with a letter for easier identification. In it, there are four nodes:\n\nA, which has 2 child nodes (B, C) and 3 metadata entries (1, 1, 2).\nB, which has 0 child nodes and 3 metadata entries (10, 11, 12).\nC, which has 1 child node (D) and 1 metadata entry (2).\nD, which has 0 child nodes and 1 metadata entry (99).\nThe first check done on the license file is to simply add up all of the metadata entries. In this example, that sum is 1+1+2+10+11+12+2+99=138.\n\nWhat is the sum of all metadata entries?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\nread_input() ->\n    {ok, Binary} = file:read_file(\"input.txt\"),\n    Input = binary_to_list(Binary),\n    lists:map(fun(X) -> list_to_integer(X) end, string:tokens(Input, \" \\t\\n\")).\n\nparse_node([ChildNodes, MetadataCount | Rest]) ->\n    {Children, Rest1} = parse_children(ChildNodes, Rest),\n    {Metadata, Rest2} = lists:split(MetadataCount, Rest1),\n    {{Children, Metadata}, Rest2}.\n\nparse_children(0, Rest) ->\n    {[], Rest};\nparse_children(N, Rest) ->\n    {Child, Rest1} = parse_node(Rest),\n    {Children, Rest2} = parse_children(N-1, Rest1),\n    {[Child | Children], Rest2}.\n\nsum_metadata({_, Metadata}) ->\n    lists:sum(Metadata).\n\ntraverse_tree({[], Metadata}) ->\n    sum_metadata({[], Metadata});\ntraverse_tree({Children, Metadata}) ->\n    lists:sum(lists:map(fun(C) -> traverse_tree(C) end, Children)) + sum_metadata({Children, Metadata}).\n\ncall() ->\n    Input = read_input(),\n    {Tree, _} = parse_node(Input),\n    Answer = traverse_tree(Tree),\n    io:format(\"~p~n\", [Answer]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: The Tyranny of the Rocket Equation ---\nSanta has become stranded at the edge of the Solar System while delivering presents to other planets! To accurately calculate his position in space, safely align his warp drive, and return to Earth in time to save Christmas, he needs you to bring him measurements from fifty stars.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nThe Elves quickly load you into a spacecraft and prepare to launch.\n\nAt the first Go / No Go poll, every Elf is Go until the Fuel Counter-Upper. They haven't determined the amount of fuel required yet.\n\nFuel required to launch a given module is based on its mass. Specifically, to find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.\n\nFor example:\n\nFor a mass of 12, divide by 3 and round down to get 4, then subtract 2 to get 2.\nFor a mass of 14, dividing by 3 and rounding down still yields 4, so the fuel required is also 2.\nFor a mass of 1969, the fuel required is 654.\nFor a mass of 100756, the fuel required is 33583.\nThe Fuel Counter-Upper needs to know the total fuel requirement. To find it, individually calculate the fuel needed for the mass of each module (your puzzle input), then add together all the fuel values.\n\nWhat is the sum of the fuel requirements for all of the modules on your spacecraft?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Input} = file:read_file(\"input.txt\"),\n    Lines = string:tokens(binary_to_list(Input), \"\\n\"),\n    TotalFuel = lists:sum([((list_to_integer(X) div 3) - 2) || X <- Lines]),\n    io:format(\"~p~n\", [TotalFuel]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 1: The Tyranny of the Rocket Equation ---\nSanta has become stranded at the edge of the Solar System while delivering presents to other planets! To accurately calculate his position in space, safely align his warp drive, and return to Earth in time to save Christmas, he needs you to bring him measurements from fifty stars.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nThe Elves quickly load you into a spacecraft and prepare to launch.\n\nAt the first Go / No Go poll, every Elf is Go until the Fuel Counter-Upper. They haven't determined the amount of fuel required yet.\n\nFuel required to launch a given module is based on its mass. Specifically, to find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.\n\nFor example:\n\nFor a mass of 12, divide by 3 and round down to get 4, then subtract 2 to get 2.\nFor a mass of 14, dividing by 3 and rounding down still yields 4, so the fuel required is also 2.\nFor a mass of 1969, the fuel required is 654.\nFor a mass of 100756, the fuel required is 33583.\nThe Fuel Counter-Upper needs to know the total fuel requirement. To find it, individually calculate the fuel needed for the mass of each module (your puzzle input), then add together all the fuel values.\n\nWhat is the sum of the fuel requirements for all of the modules on your spacecraft?\n\nYour puzzle answer was 3465154.\n\n--- Part Two ---\nDuring the second Go / No Go poll, the Elf in charge of the Rocket Equation Double-Checker stops the launch sequence. Apparently, you forgot to include additional fuel for the fuel you just added.\n\nFuel itself requires fuel just like a module - take its mass, divide by three, round down, and subtract 2. However, that fuel also requires fuel, and that fuel requires fuel, and so on. Any mass that would require negative fuel should instead be treated as if it requires zero fuel; the remaining mass, if any, is instead handled by wishing really hard, which has no mass and is outside the scope of this calculation.\n\nSo, for each module mass, calculate its fuel and add it to the total. Then, treat the fuel amount you just calculated as the input mass and repeat the process, continuing until a fuel requirement is zero or negative. For example:\n\nA module of mass 14 requires 2 fuel. This fuel requires no further fuel (2 divided by 3 and rounded down is 0, which would call for a negative fuel), so the total fuel required is still just 2.\nAt first, a module of mass 1969 requires 654 fuel. Then, this fuel requires 216 more fuel (654 / 3 - 2). 216 then requires 70 more fuel, which requires 21 fuel, which requires 5 fuel, which requires no further fuel. So, the total fuel required for a module of mass 1969 is 654 + 216 + 70 + 21 + 5 = 966.\nThe fuel required by a module of mass 100756 and its fuel is: 33583 + 11192 + 3728 + 1240 + 411 + 135 + 43 + 12 + 2 = 50346.\nWhat is the sum of the fuel requirements for all of the modules on your spacecraft when also taking into account the mass of the added fuel? (Calculate the fuel requirements for each module separately, then add them all up at the end.)\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    File = \"input.txt\",\n    {ok, Data} = file:read_file(File),\n    Numbers = string:tokens(binary_to_list(Data), \"\\n\"),\n    Fuel = lists:foldl(fun(X, Acc) -> calculate_fuel(list_to_integer(X)) + Acc end, 0, Numbers),\n    io:format(\"~p~n\", [Fuel]).\n\ncalculate_fuel(Mass) when Mass =< 0 ->\n    0;\ncalculate_fuel(Mass) ->\n    Fuel = (Mass div 3) - 2,\n    case Fuel of\n        F when F =< 0 -> 0;\n        F -> F + calculate_fuel(F)\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 6: Universal Orbit Map ---\nYou've landed at the Universal Orbit Map facility on Mercury. Because navigation in space often involves transferring between orbits, the orbit maps here are useful for finding efficient routes between, for example, you and Santa. You download a map of the local orbits (your puzzle input).\n\nExcept for the universal Center of Mass (COM), every object in space is in orbit around exactly one other object. An orbit looks roughly like this:\n\n                                                         |\n                    |\nAAA--> o            o <--BBB\n                    |\n                    |\n                   /\n                  /\nIn this diagram, the object BBB is in orbit around AAA. The path that BBB takes around AAA (drawn with lines) is only partly shown. In the map data, this orbital relationship is written AAA)BBB, which means \"BBB is in orbit around AAA\".\n\nBefore you use your map data to plot a course, you need to make sure it wasn't corrupted during the download. To verify maps, the Universal Orbit Map facility uses orbit count checksums - the total number of direct orbits (like the one shown above) and indirect orbits.\n\nWhenever A orbits B and B orbits C, then A indirectly orbits C. This chain can be any number of objects long: if A orbits B, B orbits C, and C orbits D, then A indirectly orbits D.\n\nFor example, suppose you have the following map:\n\nCOM)B\nB)C\nC)D\nD)E\nE)F\nB)G\nG)H\nD)I\nE)J\nJ)K\nK)L\nVisually, the above map of orbits looks like this:\n\n        G - H       J - K - L\n       /           /\nCOM - B - C - D - E - F\n                               I\nIn this visual representation, when two objects are connected by a line, the one on the right directly orbits the one on the left.\n\nHere, we can count the total number of orbits as follows:\n\nD directly orbits C and indirectly orbits B and COM, a total of 3 orbits.\nL directly orbits K and indirectly orbits J, E, D, C, B, and COM, a total of 7 orbits.\nCOM orbits nothing.\nThe total number of direct and indirect orbits in this example is 42.\n\nWhat is the total number of direct and indirect orbits in your map data?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Lines = string:tokens(binary_to_list(Data), \"\\n\"),\n    OrbitMap = lists:foldl(fun(Line, Map) ->\n                                [Center, Orbiter] = string:tokens(Line, \")\"),\n                                case maps:is_key(Center, Map) of\n                                    true -> NewMap = maps:update(Center, [Orbiter | maps:get(Center, Map)], Map);\n                                    false -> NewMap = maps:put(Center, [Orbiter], Map)\n                                end,\n                                NewMap\n                            end, #{}, Lines),\n    TotalOrbits = count_orbits(OrbitMap, \"COM\", 0),\n    io:format(\"~p~n\", [TotalOrbits]).\n\ncount_orbits(OrbitMap, Start, Depth) ->\n    Orbits = maps:get(Start, OrbitMap, []),\n    case length(Orbits) of\n        0 -> Depth;\n        _ -> Depth + lists:sum([count_orbits(OrbitMap, Orbit, Depth + 1) || Orbit <- Orbits])\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: Report Repair ---\nAfter saving Christmas five years in a row, you've decided to take a vacation at a nice resort on a tropical island. Surely, Christmas will go on without you.\n\nThe tropical island has its own currency and is entirely cash-only. The gold coins used there have a little picture of a starfish; the locals just call them stars. None of the currency exchanges seem to have heard of them, but somehow, you'll need to find fifty of these coins by the time you arrive so you can pay the deposit on your room.\n\nTo save your vacation, you need to get all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nBefore you leave, the Elves in accounting just need you to fix your expense report (your puzzle input); apparently, something isn't quite adding up.\n\nSpecifically, they need you to find the two entries that sum to 2020 and then multiply those two numbers together.\n\nFor example, suppose your expense report contained the following:\n\n1721\n979\n366\n299\n675\n1456\nIn this list, the two entries that sum to 2020 are 1721 and 299. Multiplying them together produces 1721 * 299 = 514579, so the correct answer is 514579.\n\nOf course, your expense report is much larger. Find the two entries that sum to 2020; what do you get if you multiply them together?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    {ok, Numbers} = read_numbers(File, []),\n    Answer = find_answer(Numbers),\n    io:format(\"~p~n\", [Answer]),\n    file:close(File).\n\nread_numbers(File, Acc) ->\n    case file:read_line(File) of\n        {ok, Line} ->\n            case string:strip(Line, right, $\\n) of\n                \"\" -> read_numbers(File, Acc);\n                NumStr -> \n                    Num = list_to_integer(NumStr),\n                    read_numbers(File, [Num | Acc])\n            end;\n        eof -> {ok, lists:reverse(Acc)}\n    end.\n\nfind_answer(Numbers) ->\n    lists:foreach(\n        fun(I) -> \n            lists:foreach(\n                fun(J) ->\n                    case I + J of\n                        2020 -> io:format(\"~p~n\", [I * J]), halt(0);\n                        _ -> ok\n                    end\n                end, Numbers)\n        end, Numbers).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 5: Binary Boarding ---\nYou board your plane only to discover a new problem: you dropped your boarding pass! You aren't sure which seat is yours, and all of the flight attendants are busy with the flood of people that suddenly made it through passport control.\n\nYou write a quick program to use your phone's camera to scan all of the nearby boarding passes (your puzzle input); perhaps you can find your seat through process of elimination.\n\nInstead of zones or groups, this airline uses binary space partitioning to seat people. A seat might be specified like FBFBBFFRLR, where F means \"front\", B means \"back\", L means \"left\", and R means \"right\".\n\nThe first 7 characters will either be F or B; these specify exactly one of the 128 rows on the plane (numbered 0 through 127). Each letter tells you which half of a region the given seat is in. Start with the whole list of rows; the first letter indicates whether the seat is in the front (0 through 63) or the back (64 through 127). The next letter indicates which half of that region the seat is in, and so on until you're left with exactly one row.\n\nFor example, consider just the first seven characters of FBFBBFFRLR:\n\nStart by considering the whole range, rows 0 through 127.\nF means to take the lower half, keeping rows 0 through 63.\nB means to take the upper half, keeping rows 32 through 63.\nF means to take the lower half, keeping rows 32 through 47.\nB means to take the upper half, keeping rows 40 through 47.\nB keeps rows 44 through 47.\nF keeps rows 44 through 45.\nThe final F keeps the lower of the two, row 44.\nThe last three characters will be either L or R; these specify exactly one of the 8 columns of seats on the plane (numbered 0 through 7). The same process as above proceeds again, this time with only three steps. L means to keep the lower half, while R means to keep the upper half.\n\nFor example, consider just the last 3 characters of FBFBBFFRLR:\n\nStart by considering the whole range, columns 0 through 7.\nR means to take the upper half, keeping columns 4 through 7.\nL means to take the lower half, keeping columns 4 through 5.\nThe final R keeps the upper of the two, column 5.\nSo, decoding FBFBBFFRLR reveals that it is the seat at row 44, column 5.\n\nEvery seat also has a unique seat ID: multiply the row by 8, then add the column. In this example, the seat has ID 44 * 8 + 5 = 357.\n\nHere are some other boarding passes:\n\nBFFFBBFRRR: row 70, column 7, seat ID 567.\nFFFBBBFRRR: row 14, column 7, seat ID 119.\nBBFFBBFRLL: row 102, column 4, seat ID 820.\nAs a sanity check, look through your list of boarding passes. What is the highest seat ID on a boarding pass?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    Data = read_lines(File, []),\n    file:close(File),\n    Seats = lists:map(fun(X) -> decode_seat(X) end, Data),\n    MaxSeatID = lists:max(Seats),\n    io:format(\"~p~n\", [MaxSeatID]).\n\nread_lines(File, Acc) ->\n    case io:get_line(File, \"\") of\n        eof -> lists:reverse(Acc);\n        Line -> read_lines(File, [Line | Acc])\n    end.\n\ndecode_seat(Code) ->\n    RowCode = string:substr(Code, 1, 7),\n    ColCode = string:substr(Code, 8, 3),\n    Row = decode_binary(RowCode, 0, 127),\n    Col = decode_binary(ColCode, 0, 7),\n    Row * 8 + Col.\n\ndecode_binary([], Min, Max) -> Min;\ndecode_binary([H | T], Min, Max) ->\n    Mid = (Min + Max + 1) div 2,\n    case H of\n        $F -> decode_binary(T, Min, Mid - 1);\n        $B -> decode_binary(T, Mid, Max);\n        $L -> decode_binary(T, Min, Mid - 1);\n        $R -> decode_binary(T, Mid, Max)\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 6: Custom Customs ---\nAs your flight approaches the regional airport where you'll switch to a much larger plane, customs declaration forms are distributed to the passengers.\n\nThe form asks a series of 26 yes-or-no questions marked a through z. All you need to do is identify the questions for which anyone in your group answers \"yes\". Since your group is just you, this doesn't take very long.\n\nHowever, the person sitting next to you seems to be experiencing a language barrier and asks if you can help. For each of the people in their group, you write down the questions for which they answer \"yes\", one per line. For example:\n\nabcx\nabcy\nabcz\nIn this group, there are 6 questions to which anyone answered \"yes\": a, b, c, x, y, and z. (Duplicate answers to the same question don't count extra; each question counts at most once.)\n\nAnother group asks for your help, then another, and eventually you've collected answers from every group on the plane (your puzzle input). Each group's answers are separated by a blank line, and within each group, each person's answers are on a single line. For example:\n\nabc\n\na\nb\nc\n\nab\nac\n\na\na\na\na\n\nb\nThis list represents answers from five groups:\n\nThe first group contains one person who answered \"yes\" to 3 questions: a, b, and c.\nThe second group contains three people; combined, they answered \"yes\" to 3 questions: a, b, and c.\nThe third group contains two people; combined, they answered \"yes\" to 3 questions: a, b, and c.\nThe fourth group contains four people; combined, they answered \"yes\" to only 1 question, a.\nThe last group contains one person who answered \"yes\" to only 1 question, b.\nIn this example, the sum of these counts is 3 + 3 + 3 + 1 + 1 = 11.\n\nFor each group, count the number of questions to which anyone answered \"yes\". What is the sum of those counts?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Groups = string:split(binary_to_list(File), \"\\n\\n\", all),\n    Answer = lists:sum([length(lists:usort(lists:flatten(string:tokens(Group, \"\\n\")))) || Group <- Groups]),\n    io:format(\"~p~n\", [Answer]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 13: Shuttle Search ---\nYour ferry can make it safely to a nearby port, but it won't get much further. When you call to book another ship, you discover that no ships embark from that port to your vacation island. You'll need to get from the port to the nearest airport.\n\nFortunately, a shuttle bus service is available to bring you from the sea port to the airport! Each bus has an ID number that also indicates how often the bus leaves for the airport.\n\nBus schedules are defined based on a timestamp that measures the number of minutes since some fixed reference point in the past. At timestamp 0, every bus simultaneously departed from the sea port. After that, each bus travels to the airport, then various other locations, and finally returns to the sea port to repeat its journey forever.\n\nThe time this loop takes a particular bus is also its ID number: the bus with ID 5 departs from the sea port at timestamps 0, 5, 10, 15, and so on. The bus with ID 11 departs at 0, 11, 22, 33, and so on. If you are there when the bus departs, you can ride that bus to the airport!\n\nYour notes (your puzzle input) consist of two lines. The first line is your estimate of the earliest timestamp you could depart on a bus. The second line lists the bus IDs that are in service according to the shuttle company; entries that show x must be out of service, so you decide to ignore them.\n\nTo save time once you arrive, your goal is to figure out the earliest bus you can take to the airport. (There will be exactly one such bus.)\n\nFor example, suppose you have the following notes:\n\n939\n7,13,x,x,59,x,31,19\nHere, the earliest timestamp you could depart is 939, and the bus IDs in service are 7, 13, 59, 31, and 19. Near timestamp 939, these bus IDs depart at the times marked D:\n\ntime   bus 7   bus 13  bus 59  bus 31  bus 19\n929      .       .       .       .       .\n930      .       .       .       D       .\n931      D       .       .       .       D\n932      .       .       .       .       .\n933      .       .       .       .       .\n934      .       .       .       .       .\n935      .       .       .       .       .\n936      .       D       .       .       .\n937      .       .       .       .       .\n938      D       .       .       .       .\n939      .       .       .       .       .\n940      .       .       .       .       .\n941      .       .       .       .       .\n942      .       .       .       .       .\n943      .       .       .       .       .\n944      .       .       D       .       .\n945      D       .       .       .       .\n946      .       .       .       .       .\n947      .       .       .       .       .\n948      .       .       .       .       .\n949      .       D       .       .       .\nThe earliest bus you could take is bus ID 59. It doesn't depart until timestamp 944, so you would need to wait 944 - 939 = 5 minutes before it departs. Multiplying the bus ID by the number of minutes you'd need to wait gives 295.\n\nWhat is the ID of the earliest bus you can take to the airport multiplied by the number of minutes you'll need to wait for that bus?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    {ok, [EarliestDeparture]} = io:fread(File, \"\", \"~d\"),\n    {ok, [BusIDs]} = io:fread(File, \"\", \"~s\"),\n    file:close(File),\n    \n    {EarliestBusID, MinWaitTime} = lists:foldl(\n        fun(Id, {EarliestID, MinTime}) ->\n            case Id of\n                \"x\" -> {EarliestID, MinTime};\n                _ ->\n                    BusID = list_to_integer(Id),\n                    WaitTime = BusID - (EarliestDeparture rem BusID),\n                    case WaitTime < MinTime of\n                        true -> {BusID, WaitTime};\n                        false -> {EarliestID, MinTime}\n                    end\n            end\n        end,\n        {0, EarliestDeparture},\n        string:tokens(BusIDs, \",\")\n    ),\n    \n    io:format(\"~p~n\", [EarliestBusID * MinWaitTime]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 15: Rambunctious Recitation ---\nYou catch the airport shuttle and try to book a new flight to your vacation island. Due to the storm, all direct flights have been cancelled, but a route is available to get around the storm. You take it.\n\nWhile you wait for your flight, you decide to check in with the Elves back at the North Pole. They're playing a memory game and are ever so excited to explain the rules!\n\nIn this game, the players take turns saying numbers. They begin by taking turns reading from a list of starting numbers (your puzzle input). Then, each turn consists of considering the most recently spoken number:\n\nIf that was the first time the number has been spoken, the current player says 0.\nOtherwise, the number had been spoken before; the current player announces how many turns apart the number is from when it was previously spoken.\nSo, after the starting numbers, each turn results in that player speaking aloud either 0 (if the last number is new) or an age (if the last number is a repeat).\n\nFor example, suppose the starting numbers are 0,3,6:\n\nTurn 1: The 1st number spoken is a starting number, 0.\nTurn 2: The 2nd number spoken is a starting number, 3.\nTurn 3: The 3rd number spoken is a starting number, 6.\nTurn 4: Now, consider the last number spoken, 6. Since that was the first time the number had been spoken, the 4th number spoken is 0.\nTurn 5: Next, again consider the last number spoken, 0. Since it had been spoken before, the next number to speak is the difference between the turn number when it was last spoken (the previous turn, 4) and the turn number of the time it was most recently spoken before then (turn 1). Thus, the 5th number spoken is 4 - 1, 3.\nTurn 6: The last number spoken, 3 had also been spoken before, most recently on turns 5 and 2. So, the 6th number spoken is 5 - 2, 3.\nTurn 7: Since 3 was just spoken twice in a row, and the last two turns are 1 turn apart, the 7th number spoken is 1.\nTurn 8: Since 1 is new, the 8th number spoken is 0.\nTurn 9: 0 was last spoken on turns 8 and 4, so the 9th number spoken is the difference between them, 4.\nTurn 10: 4 is new, so the 10th number spoken is 0.\n(The game ends when the Elves get sick of playing or dinner is ready, whichever comes first.)\n\nTheir question for you is: what will be the 2020th number spoken? In the example above, the 2020th number spoken will be 436.\n\nHere are a few more examples:\n\nGiven the starting numbers 1,3,2, the 2020th number spoken is 1.\nGiven the starting numbers 2,1,3, the 2020th number spoken is 10.\nGiven the starting numbers 1,2,3, the 2020th number spoken is 27.\nGiven the starting numbers 2,3,1, the 2020th number spoken is 78.\nGiven the starting numbers 3,2,1, the 2020th number spoken is 438.\nGiven the starting numbers 3,1,2, the 2020th number spoken is 1836.\nGiven your starting numbers, what will be the 2020th number spoken?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Input} = file:read_file(\"input.txt\"),\n    StartingNumbers = string:tokens(binary:bin_to_list(Input), \",\\n\"),\n    LastSpoken = dict:new(),\n    {_, Answer} = lists:foldl(fun(Turn, {PrevNumber, LastSpokenDict}) ->\n        case Turn of\n            1 -> {list_to_integer(hd(StartingNumbers)), LastSpokenDict};\n            _ when Turn =< 2020 ->\n                LastNumber = PrevNumber,\n                NextNumber = case dict:find(LastNumber, LastSpokenDict) of\n                    {ok, LastTurn} when LastTurn /= Turn-1 -> Turn-1 - LastTurn;\n                    _ -> 0\n                end,\n                NewLastSpokenDict = dict:store(LastNumber, Turn-1, LastSpokenDict),\n                {NextNumber, NewLastSpokenDict}\n        end\n    end, {0, LastSpoken}, lists:seq(1, 2020)),\n    io:format(\"~p~n\", [Answer]).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 25: Combo Breaker ---\nYou finally reach the check-in desk. Unfortunately, their registration systems are currently offline, and they cannot check you in. Noticing the look on your face, they quickly add that tech support is already on the way! They even created all the room keys this morning; you can take yours now and give them your room deposit once the registration system comes back online.\n\nThe room key is a small RFID card. Your room is on the 25th floor and the elevators are also temporarily out of service, so it takes what little energy you have left to even climb the stairs and navigate the halls. You finally reach the door to your room, swipe your card, and - beep - the light turns red.\n\nExamining the card more closely, you discover a phone number for tech support.\n\n\"Hello! How can we help you today?\" You explain the situation.\n\n\"Well, it sounds like the card isn't sending the right command to unlock the door. If you go back to the check-in desk, surely someone there can reset it for you.\" Still catching your breath, you describe the status of the elevator and the exact number of stairs you just had to climb.\n\n\"I see! Well, your only other option would be to reverse-engineer the cryptographic handshake the card does with the door and then inject your own commands into the data stream, but that's definitely impossible.\" You thank them for their time.\n\nUnfortunately for the door, you know a thing or two about cryptographic handshakes.\n\nThe handshake used by the card and the door involves an operation that transforms a subject number. To transform a subject number, start with the value 1. Then, a number of times called the loop size, perform the following steps:\n\nSet the value to itself multiplied by the subject number.\nSet the value to the remainder after dividing the value by 20201227.\nThe card always uses a specific, secret loop size when it transforms a subject number. The door always uses a different, secret loop size.\n\nThe cryptographic handshake works like this:\n\nThe card transforms the subject number of 7 according to the card's secret loop size. The result is called the card's public key.\nThe door transforms the subject number of 7 according to the door's secret loop size. The result is called the door's public key.\nThe card and door use the wireless RFID signal to transmit the two public keys (your puzzle input) to the other device. Now, the card has the door's public key, and the door has the card's public key. Because you can eavesdrop on the signal, you have both public keys, but neither device's loop size.\nThe card transforms the subject number of the door's public key according to the card's loop size. The result is the encryption key.\nThe door transforms the subject number of the card's public key according to the door's loop size. The result is the same encryption key as the card calculated.\nIf you can use the two public keys to determine each device's loop size, you will have enough information to calculate the secret encryption key that the card and door use to communicate; this would let you send the unlock command directly to the door!\n\nFor example, suppose you know that the card's public key is 5764801. With a little trial and error, you can work out that the card's loop size must be 8, because transforming the initial subject number of 7 with a loop size of 8 produces 5764801.\n\nThen, suppose you know that the door's public key is 17807724. By the same process, you can determine that the door's loop size is 11, because transforming the initial subject number of 7 with a loop size of 11 produces 17807724.\n\nAt this point, you can use either device's loop size with the other device's public key to calculate the encryption key. Transforming the subject number of 17807724 (the door's public key) with a loop size of 8 (the card's loop size) produces the encryption key, 14897079. (Transforming the subject number of 5764801 (the card's public key) with a loop size of 11 (the door's loop size) produces the same encryption key: 14897079.)\n\nWhat encryption key is the handshake trying to establish?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    [CardPublicKeyStr, DoorPublicKeyStr] = string:tokens(binary_to_list(File), \"\\n\"),\n    CardPublicKey = list_to_integer(CardPublicKeyStr),\n    DoorPublicKey = list_to_integer(DoorPublicKeyStr),\n    CardLoopSize = find_loop_size(CardPublicKey, 1, 0),\n    EncryptionKey = transform(DoorPublicKey, CardLoopSize),\n    io:format(\"~p~n\", [EncryptionKey]).\n\nfind_loop_size(PublicKey, Value, LoopSize) when Value =:= PublicKey ->\n    LoopSize;\nfind_loop_size(PublicKey, Value, LoopSize) ->\n    NewValue = (Value * 7) rem 20201227,\n    find_loop_size(PublicKey, NewValue, LoopSize + 1).\n\ntransform(SubjectNumber, LoopSize) ->\n    lists:foldl(fun(_, Acc) -> (Acc * SubjectNumber) rem 20201227 end, 1, lists:seq(1, LoopSize)).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: Sonar Sweep ---\nYou're minding your own business on a ship at sea when the overboard alarm goes off! You rush to see if you can help. Apparently, one of the Elves tripped and accidentally sent the sleigh keys flying into the ocean!\n\nBefore you know it, you're inside a submarine the Elves keep ready for situations like this. It's covered in Christmas lights (because of course it is), and it even has an experimental antenna that should be able to track the keys if you can boost its signal strength high enough; there's a little meter that indicates the antenna's signal strength by displaying 0-50 stars.\n\nYour instincts tell you that in order to save Christmas, you'll need to get all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nAs the submarine drops below the surface of the ocean, it automatically performs a sonar sweep of the nearby sea floor. On a small screen, the sonar sweep report (your puzzle input) appears: each line is a measurement of the sea floor depth as the sweep looks further and further away from the submarine.\n\nFor example, suppose you had the following report:\n\n199\n200\n208\n210\n200\n207\n240\n269\n260\n263\nThis report indicates that, scanning outward from the submarine, the sonar sweep found depths of 199, 200, 208, 210, and so on.\n\nThe first order of business is to figure out how quickly the depth increases, just so you know what you're dealing with - you never know if the keys will get carried into deeper water by an ocean current or a fish or something.\n\nTo do this, count the number of times a depth measurement increases from the previous measurement. (There is no measurement before the first measurement.) In the example above, the changes are as follows:\n\n199 (N/A - no previous measurement)\n200 (increased)\n208 (increased)\n210 (increased)\n200 (decreased)\n207 (increased)\n240 (increased)\n269 (increased)\n260 (decreased)\n263 (increased)\nIn this example, there are 7 measurements that are larger than the previous measurement.\n\nHow many measurements are larger than the previous measurement?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    {ok, Count} = count_inversions(File, 0, 0),\n    io:format(\"~p~n\", [Count]),\n    file:close(File).\n\ncount_inversions(File, Prev, Count) ->\n    case io:get_line(File, \"\") of\n        eof ->\n            {ok, Count};\n        {error, Reason} ->\n            {error, Reason};\n        Line ->\n            [NumStr | _] = string:tokens(Line, \"\\n\"),\n            Current = list_to_integer(NumStr),\n            if\n                Prev /= 0 andalso Current > Prev ->\n                    count_inversions(File, Current, Count + 1);\n                true ->\n                    count_inversions(File, Current, Count)\n            end\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 21: Dirac Dice ---\nThere's not much to do as you slowly descend to the bottom of the ocean. The submarine computer challenges you to a nice game of Dirac Dice.\n\nThis game consists of a single die, two pawns, and a game board with a circular track containing ten spaces marked 1 through 10 clockwise. Each player's starting space is chosen randomly (your puzzle input). Player 1 goes first.\n\nPlayers take turns moving. On each player's turn, the player rolls the die three times and adds up the results. Then, the player moves their pawn that many times forward around the track (that is, moving clockwise on spaces in order of increasing value, wrapping back around to 1 after 10). So, if a player is on space 7 and they roll 2, 2, and 1, they would move forward 5 times, to spaces 8, 9, 10, 1, and finally stopping on 2.\n\nAfter each player moves, they increase their score by the value of the space their pawn stopped on. Players' scores start at 0. So, if the first player starts on space 7 and rolls a total of 5, they would stop on space 2 and add 2 to their score (for a total score of 2). The game immediately ends as a win for any player whose score reaches at least 1000.\n\nSince the first game is a practice game, the submarine opens a compartment labeled deterministic dice and a 100-sided die falls out. This die always rolls 1 first, then 2, then 3, and so on up to 100, after which it starts over at 1 again. Play using this die.\n\nFor example, given these starting positions:\n\nPlayer 1 starting position: 4\nPlayer 2 starting position: 8\nThis is how the game would go:\n\nPlayer 1 rolls 1+2+3 and moves to space 10 for a total score of 10.\nPlayer 2 rolls 4+5+6 and moves to space 3 for a total score of 3.\nPlayer 1 rolls 7+8+9 and moves to space 4 for a total score of 14.\nPlayer 2 rolls 10+11+12 and moves to space 6 for a total score of 9.\nPlayer 1 rolls 13+14+15 and moves to space 6 for a total score of 20.\nPlayer 2 rolls 16+17+18 and moves to space 7 for a total score of 16.\nPlayer 1 rolls 19+20+21 and moves to space 6 for a total score of 26.\nPlayer 2 rolls 22+23+24 and moves to space 6 for a total score of 22.\n...after many turns...\n\nPlayer 2 rolls 82+83+84 and moves to space 6 for a total score of 742.\nPlayer 1 rolls 85+86+87 and moves to space 4 for a total score of 990.\nPlayer 2 rolls 88+89+90 and moves to space 3 for a total score of 745.\nPlayer 1 rolls 91+92+93 and moves to space 10 for a final score, 1000.\nSince player 1 has at least 1000 points, player 1 wins and the game ends. At this point, the losing player had 745 points and the die had been rolled a total of 993 times; 745 * 993 = 739785.\n\nPlay a practice game using the deterministic 100-sided die. The moment either player wins, what do you get if you multiply the score of the losing player by the number of times the die was rolled during the game?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, Data} = file:read_file(\"input.txt\"),\n    Lines = string:tokens(binary_to_list(Data), \"\\n\"),\n    Player1Start = list_to_integer(string:substr(lists:nth(1, Lines), 29, 3)),\n    Player2Start = list_to_integer(string:substr(lists:nth(2, Lines), 29, 3)),\n    Player1Pos = Player1Start,\n    Player2Pos = Player2Start,\n    Player1Score = 0,\n    Player2Score = 0,\n    DieRoll = 1,\n    RollCount = 0,\n    play(Player1Pos, Player2Pos, Player1Score, Player2Score, DieRoll, RollCount).\n\nplay(Player1Pos, Player2Pos, Player1Score, Player2Score, DieRoll, RollCount) ->\n    Rolls1 = DieRoll rem 100 + (DieRoll+1) rem 100 + (DieRoll+2) rem 100,\n    RollCount1 = RollCount + 3,\n    DieRoll1 = DieRoll + 3,\n    Player1Pos1 = (Player1Pos + Rolls1 - 1) rem 10 + 1,\n    Player1Score1 = Player1Score + Player1Pos1,\n    case Player1Score1 >= 1000 of\n        true -> io:format(\"Result: ~p~n\", [Player2Score*RollCount1]);\n        false -> Rolls2 = DieRoll1 rem 100 + (DieRoll1+1) rem 100 + (DieRoll1+2) rem 100,\n                  RollCount2 = RollCount1 + 3,\n                  DieRoll2 = DieRoll1 + 3,\n                  Player2Pos1 = (Player2Pos + Rolls2 - 1) rem 10 + 1,\n                  Player2Score1 = Player2Score + Player2Pos1,\n                  case Player2Score1 >= 1000 of\n                      true -> io:format(\"Result: ~p~n\", [Player1Score1 * RollCount2]);\n                      false -> play(Player1Pos1, Player2Pos1, Player1Score1, Player2Score1, DieRoll2, RollCount2)\n                  end\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 1: Calorie Counting ---\nSanta's reindeer typically eat regular reindeer food, but they need a lot of magical energy to deliver presents on Christmas. For that, their favorite snack is a special type of star fruit that only grows deep in the jungle. The Elves have brought you on their annual expedition to the grove where the fruit grows.\n\nTo supply enough magical energy, the expedition needs to retrieve a minimum of fifty stars by December 25th. Although the Elves assure you that the grove has plenty of fruit, you decide to grab any fruit you see along the way, just in case.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nThe jungle must be too overgrown and difficult to navigate in vehicles or access from the air; the Elves' expedition traditionally goes on foot. As your boats approach land, the Elves begin taking inventory of their supplies. One important consideration is food - in particular, the number of Calories each Elf is carrying (your puzzle input).\n\nThe Elves take turns writing down the number of Calories contained by the various meals, snacks, rations, etc. that they've brought with them, one item per line. Each Elf separates their own inventory from the previous Elf's inventory (if any) by a blank line.\n\nFor example, suppose the Elves finish writing their items' Calories and end up with the following list:\n\n1000\n2000\n3000\n\n4000\n\n5000\n6000\n\n7000\n8000\n9000\n\n10000\nThis list represents the Calories of the food carried by five Elves:\n\nThe first Elf is carrying food with 1000, 2000, and 3000 Calories, a total of 6000 Calories.\nThe second Elf is carrying one food item with 4000 Calories.\nThe third Elf is carrying food with 5000 and 6000 Calories, a total of 11000 Calories.\nThe fourth Elf is carrying food with 7000, 8000, and 9000 Calories, a total of 24000 Calories.\nThe fifth Elf is carrying one food item with 10000 Calories.\nIn case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they'd like to know how many Calories are being carried by the Elf carrying the most Calories. In the example above, this is 24000 (carried by the fourth Elf).\n\nFind the Elf carrying the most Calories. How many total Calories is that Elf carrying?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    {ok, Answer} = find_max_calories(File, 0, 0),\n    io:format(\"~p~n\", [Answer]),\n    file:close(File).\n\nfind_max_calories(File, MaxCalories, CurrentCalories) ->\n    case file:read_line(File) of\n        {ok, Line} ->\n            case Line of\n                \"\\n\" ->\n                    if CurrentCalories > MaxCalories ->\n                        find_max_calories(File, CurrentCalories, 0);\n                    true ->\n                        find_max_calories(File, MaxCalories, 0)\n                    end;\n                _ ->\n                    case list_to_integer(string:strip(Line, right, $\\n)) of\n                        {error, _} -> find_max_calories(File, MaxCalories, CurrentCalories);\n                        Calories -> find_max_calories(File, MaxCalories, CurrentCalories + Calories)\n                    end\n            end;\n        eof ->\n            if CurrentCalories > MaxCalories ->\n                {ok, CurrentCalories};\n            true ->\n                {ok, MaxCalories}\n            end\n    end.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 2: Rock Paper Scissors ---\nThe Elves begin to set up camp on the beach. To decide whose tent gets to be closest to the snack storage, a giant Rock Paper Scissors tournament is already in progress.\n\nRock Paper Scissors is a game between two players. Each game contains many rounds; in each round, the players each simultaneously choose one of Rock, Paper, or Scissors using a hand shape. Then, a winner for that round is selected: Rock defeats Scissors, Scissors defeats Paper, and Paper defeats Rock. If both players choose the same shape, the round instead ends in a draw.\n\nAppreciative of your help yesterday, one Elf gives you an encrypted strategy guide (your puzzle input) that they say will be sure to help you win. \"The first column is what your opponent is going to play: A for Rock, B for Paper, and C for Scissors. The second column--\" Suddenly, the Elf is called away to help with someone's tent.\n\nThe second column, you reason, must be what you should play in response: X for Rock, Y for Paper, and Z for Scissors. Winning every time would be suspicious, so the responses must have been carefully chosen.\n\nThe winner of the whole tournament is the player with the highest score. Your total score is the sum of your scores for each round. The score for a single round is the score for the shape you selected (1 for Rock, 2 for Paper, and 3 for Scissors) plus the score for the outcome of the round (0 if you lost, 3 if the round was a draw, and 6 if you won).\n\nSince you can't be sure if the Elf is trying to help you or trick you, you should calculate the score you would get if you were to follow the strategy guide.\n\nFor example, suppose you were given the following strategy guide:\n\nA Y\nB X\nC Z\nThis strategy guide predicts and recommends the following:\n\nIn the first round, your opponent will choose Rock (A), and you should choose Paper (Y). This ends in a win for you with a score of 8 (2 because you chose Paper + 6 because you won).\nIn the second round, your opponent will choose Paper (B), and you should choose Rock (X). This ends in a loss for you with a score of 1 (1 + 0).\nThe third round is a draw with both players choosing Scissors, giving you a score of 3 + 3 = 6.\nIn this example, if you were to follow the strategy guide, you would get a total score of 15 (8 + 1 + 6).\n\nWhat would your total score be if everything goes exactly according to your strategy guide?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    Input = \"input.txt\",\n    {ok, File} = file:read_file(Input),\n    Lines = string:tokens(binary_to_list(File), \"\\n\"),\n    TotalScore = calculate_score(Lines, 0),\n    io:format(\"~p~n\", [TotalScore]).\n\ncalculate_score([], Score) -> Score;\ncalculate_score([Line | Rest], Score) ->\n    [Opponent, Response] = string:tokens(Line, \" \"),\n    OpponentScore = case Opponent of\n                        \"A\" -> 1;\n                        \"B\" -> 2;\n                        \"C\" -> 3\n                    end,\n    ResponseScore = case Response of\n                        \"X\" -> 1;\n                        \"Y\" -> 2;\n                        \"Z\" -> 3\n                    end,\n    Outcome = case OpponentScore of\n                1 when ResponseScore == 2 -> 6;\n                2 when ResponseScore == 3 -> 6;\n                3 when ResponseScore == 1 -> 6;\n                _ when OpponentScore == ResponseScore -> 3;\n                _ -> 0\n              end,\n    calculate_score(Rest, Score + ResponseScore + Outcome).\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve challenge\n  Result = ...,\n  \n  % Print result \n  io:format(\"~p~n\", [Result]).\n```\n\nAim to write clean, efficient erlang code that demonstrates strong programming skills.\n\nCoding challenge:\n```text\n--- Day 3: Rucksack Reorganization ---\nOne Elf has the important job of loading all of the rucksacks with supplies for the jungle journey. Unfortunately, that Elf didn't quite follow the packing instructions, and so a few items now need to be rearranged.\n\nEach rucksack has two large compartments. All items of a given type are meant to go into exactly one of the two compartments. The Elf that did the packing failed to follow this rule for exactly one item type per rucksack.\n\nThe Elves have made a list of all of the items currently in each rucksack (your puzzle input), but they need your help finding the errors. Every item type is identified by a single lowercase or uppercase letter (that is, a and A refer to different types of items).\n\nThe list of items for each rucksack is given as characters all on a single line. A given rucksack always has the same number of items in each of its two compartments, so the first half of the characters represent items in the first compartment, while the second half of the characters represent items in the second compartment.\n\nFor example, suppose you have the following list of contents from six rucksacks:\n\nvJrwpWtwJgWrhcsFMMfFFhFp\njqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL\nPmmdzqPrVvPwwTWBwg\nwMqvLMZHhHMvwLHjbvcjnnSBnvTQFn\nttgJtRGJQctTZtZT\nCrZsJsPPZsGzwwsLwLmpwMDw\nThe first rucksack contains the items vJrwpWtwJgWrhcsFMMfFFhFp, which means its first compartment contains the items vJrwpWtwJgWr, while the second compartment contains the items hcsFMMfFFhFp. The only item type that appears in both compartments is lowercase p.\nThe second rucksack's compartments contain jqHRNqRjqzjGDLGL and rsFMfFZSrLrFZsSL. The only item type that appears in both compartments is uppercase L.\nThe third rucksack's compartments contain PmmdzqPrV and vPwwTWBwg; the only common item type is uppercase P.\nThe fourth rucksack's compartments only share item type v.\nThe fifth rucksack's compartments only share item type t.\nThe sixth rucksack's compartments only share item type s.\nTo help prioritize item rearrangement, every item type can be converted to a priority:\n\nLowercase item types a through z have priorities 1 through 26.\nUppercase item types A through Z have priorities 27 through 52.\nIn the above example, the priority of the item type that appears in both compartments of each rucksack is 16 (p), 38 (L), 42 (P), 22 (v), 20 (t), and 19 (s); the sum of these is 157.\n\nFind the item type that appears in both compartments of each rucksack. What is the sum of the priorities of those item types?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n    {ok, File} = file:open(\"input.txt\", [read]),\n    Answer = process_lines(File, 0),\n    io:format(\"~p~n\", [Answer]),\n    file:close(File).\n\nprocess_lines(File, Sum) ->\n    case file:read_line(File) of\n        {ok, Line} ->\n            Half = length(Line) div 2,\n            FirstCompartment = lists:sublist(Line, Half),\n            SecondCompartment = lists:nthtail(Half, Line),\n            CompartmentMap = lists:foldl(fun(Item, Map) -> \n                                            NewMap = maps:put(Item, maps:get(Item, Map, 0) + 1, Map),\n                                            NewMap\n                                        end, #{}, FirstCompartment),\n            Sum1 = check_second_compartment(SecondCompartment, CompartmentMap, Sum),\n            process_lines(File, Sum1);\n        eof ->\n            Sum\n    end.\n\ncheck_second_compartment([], _, Sum) ->\n    Sum;\ncheck_second_compartment([Item|Rest], CompartmentMap, Sum) ->\n    case maps:is_key(Item, CompartmentMap) of\n        true -> \n            Sum + item_priority(Item);\n        false ->\n            check_second_compartment(Rest, CompartmentMap, Sum)\n    end.\n\nitem_priority(Item) when Item >= $a, Item =< $z ->\n    Item - $a + 1;\nitem_priority(Item) when Item >= $A, Item =< $Z ->\n    Item - $A + 27.\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an erlang program that reads input from a file called input.txt and prints the output to standard output.\nStructure the program as a module named task, with a single exported function call/0 that takes no arguments.\nThe program structure should follow this template:\n```erlang\n-module(task).\n-export([call/0]).\n\ncall() ->\n  % Read input and solve Part 2\n  Result2 = ..., \n  \n  % Print Part 2 result\n  io:format(\"~p~n\", [Result2]).\n```\n\nFocus on writing clean, efficient Erlang code that demonstrates your programming skills by concisely solving Part 2 of the challenge.\n\nCoding challenge:\n```text\n--- Day 4: Camp Cleanup ---\nSpace needs to be cleared before the last supplies can be unloaded from the ships, and so several Elves have been assigned the job of cleaning up sections of the camp. Every section has a unique ID number, and each Elf is assigned a range of section IDs.\n\nHowever, as some of the Elves compare their section assignments with each other, they've noticed that many of the assignments overlap. To try to quickly find overlaps and reduce duplicated effort, the Elves pair up and make a big list of the section assignments for each pair (your puzzle input).\n\nFor example, consider the following list of section assignment pairs:\n\n2-4,6-8\n2-3,4-5\n5-7,7-9\n2-8,3-7\n6-6,4-6\n2-6,4-8\nFor the first few pairs, this list means:\n\nWithin the first pair of Elves, the first Elf was assigned sections 2-4 (sections 2, 3, and 4), while the second Elf was assigned sections 6-8 (sections 6, 7, 8).\nThe Elves in the second pair were each assigned two sections.\nThe Elves in the third pair were each assigned three sections: one got sections 5, 6, and 7, while the other also got 7, plus 8 and 9.\nThis example list uses single-digit section IDs to make it easier to draw; your actual list might contain larger numbers. Visually, these pairs of section assignments look like this:\n\n.234.....  2-4\n.....678.  6-8\n\n.23......  2-3\n...45....  4-5\n\n....567..  5-7\n......789  7-9\n\n.2345678.  2-8\n..34567..  3-7\n\n.....6...  6-6\n...456...  4-6\n\n.23456...  2-6\n...45678.  4-8\nSome of the pairs have noticed that one of their assignments fully contains the other. For example, 2-8 fully contains 3-7, and 6-6 is fully contained by 4-6. In pairs where one assignment fully contains the other, one Elf in the pair would be exclusively cleaning sections their partner will already be cleaning, so these seem like the most in need of reconsideration. In this example, there are 2 such pairs.\n\nIn how many assignment pairs does one range fully contain the other?\n\nYour puzzle answer was 526.\n\n--- Part Two ---\nIt seems like there is still quite a bit of duplicate work planned. Instead, the Elves would like to know the number of pairs that overlap at all.\n\nIn the above example, the first two pairs (2-4,6-8 and 2-3,4-5) don't overlap, while the remaining four pairs (5-7,7-9, 2-8,3-7, 6-6,4-6, and 2-6,4-8) do overlap:\n\n5-7,7-9 overlaps in a single section, 7.\n2-8,3-7 overlaps all of the sections 3 through 7.\n6-6,4-6 overlaps in a single section, 6.\n2-6,4-8 overlaps in sections 4, 5, and 6.\nSo, in this example, the number of overlapping assignment pairs is 4.\n\nIn how many assignment pairs do the ranges overlap?\n```\n","role":"user"},{"content":"Here is a solution of the challenge:\n```erlang\n-module(task).\n-export([call/0]).\n\nparse_line(Line) ->\n    [Start1, End1, Start2, End2] = [list_to_integer(X) || X <- string:tokens(Line, \"-, \")],\n    {Start1, End1, Start2, End2}.\n\noverlap({Start1, End1, Start2, End2}) ->\n    max(0, min(End1, End2) - max(Start1, Start2) + 1).\n\npart1() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Lines = string:split(binary_to_list(File), \"\\n\", all),\n    Pairs = [parse_line(Line) || Line <- Lines],\n    Count = length([true || {Start1, End1, Start2, End2} <- Pairs, overlap({Start1, End1, Start2, End2}) > 0]),\n    Count.\n\npart2() ->\n    {ok, File} = file:read_file(\"input.txt\"),\n    Lines = string:split(binary_to_list(File), \"\\n\", all),\n    Pairs = [parse_line(Line) || Line <- Lines],\n    Count = length([true || {Start1, End1, Start2, End2} <- Pairs, overlap({Start1, End1, Start2, End2}) > 0]),\n    Count.\n\ncall() ->\n    Part1 = part1(),\n    Part2 = part2(),\n    io:format(\"Part 1: ~p~nPart 2: ~p~n\", [Part1, Part2]).\n```\n","role":"assistant"}]}
