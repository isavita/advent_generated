{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 1: Not Quite Lisp ---\nSanta was hoping for a white Christmas, but his weather machine's \"snow\" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\n\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nHere's an easy puzzle to warm you up.\n\nSanta is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\n\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\n\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\n\nFor example:\n\n(()) and ()() both result in floor 0.\n((( and (()(()( both result in floor 3.\n))((((( also results in floor 3.\n()) and ))( both result in floor -1 (the first basement level).\n))) and )())()) both result in floor -3.\nTo what floor do the instructions take Santa?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var floor: i32 = 0;\n\n    while (true) {\n        const char = in_stream.readByte() catch |err| switch (err) {\n            error.EndOfStream => break,\n            else => return err,\n        };\n\n        switch (char) {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            else => unreachable,\n        }\n    }\n\n    std.debug.print(\"Final floor: {}\\n\", .{floor});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 1: Not Quite Lisp ---\nSanta was hoping for a white Christmas, but his weather machine's \"snow\" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\n\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nHere's an easy puzzle to warm you up.\n\nSanta is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\n\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\n\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\n\nFor example:\n\n(()) and ()() both result in floor 0.\n((( and (()(()( both result in floor 3.\n))((((( also results in floor 3.\n()) and ))( both result in floor -1 (the first basement level).\n))) and )())()) both result in floor -3.\nTo what floor do the instructions take Santa?\n\nYour puzzle answer was 280.\n\n--- Part Two ---\nNow, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\n\nFor example:\n\n) causes him to enter the basement at character position 1.\n()()) causes him to enter the basement at character position 5.\nWhat is the position of the character that causes Santa to first enter the basement?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var floor: i32 = 0;\n    var basement_pos: ?usize = null;\n\n    var pos: usize = 1;\n    while (true) {\n        const char = in_stream.readByte() catch |err| switch (err) {\n            error.EndOfStream => break,\n            else => return err,\n        };\n\n        switch (char) {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            else => unreachable,\n        }\n\n        if (floor == -1 and basement_pos == null) {\n            basement_pos = pos;\n        }\n\n        pos += 1;\n    }\n\n    std.debug.print(\"Final floor: {}\\n\", .{floor});\n    std.debug.print(\"First basement position: {}\\n\", .{basement_pos.?});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: I Was Told There Would Be No Math ---\nThe elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\n\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\n\nFor example:\n\nA present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet.\nA present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.\nAll numbers in the elves' list are in feet. How many total square feet of wrapping paper should they order?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn min(vals: []const i32) i32 {\n    var minVal = vals[0];\n    for (vals[1..]) |val| {\n        if (val < minVal) {\n            minVal = val;\n        }\n    }\n    return minVal;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var in_stream = reader.reader();\n\n    var total: i32 = 0;\n    var buf: [1024]u8 = undefined;\n    while (try in_stream.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        if (line.len == 0) continue;\n\n        var parts = std.mem.split(u8, line, \"x\");\n        const l = try std.fmt.parseInt(i32, parts.next().?, 10);\n        const w = try std.fmt.parseInt(i32, parts.next().?, 10);\n        const h = try std.fmt.parseInt(i32, parts.next().?, 10);\n\n        const side1 = l * w;\n        const side2 = w * h;\n        const side3 = h * l;\n\n        const smallest = min(&[_]i32{ side1, side2, side3 });\n        total += 2 * side1 + 2 * side2 + 2 * side3 + smallest;\n    }\n\n    std.debug.print(\"{d}\\n\", .{total});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 3: Perfectly Spherical Houses in a Vacuum ---\nSanta is delivering presents to an infinite two-dimensional grid of houses.\n\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (>), or west (<). After each move, he delivers another present to the house at his new location.\n\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\n\nFor example:\n\n> delivers presents to 2 houses: one at the starting location, and one to the east.\n^>v< delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.\n^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    const directions = try file.readToEndAlloc(std.heap.page_allocator, 1024 * 1024);\n    defer std.heap.page_allocator.free(directions);\n\n    var visited_houses = std.AutoHashMap([2]i32, bool).init(std.heap.page_allocator);\n    defer visited_houses.deinit();\n\n    var x: i32 = 0;\n    var y: i32 = 0;\n    try visited_houses.put([2]i32{ x, y }, true);\n\n    for (directions) |dir| {\n        switch (dir) {\n            '^' => y += 1, // Move north\n            'v' => y -= 1, // Move south\n            '>' => x += 1, // Move east\n            '<' => x -= 1, // Move west\n            else => {},\n        }\n        try visited_houses.put([2]i32{ x, y }, true);\n    }\n\n    std.debug.print(\"{}\\n\", .{visited_houses.count()});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 3: Perfectly Spherical Houses in a Vacuum ---\nSanta is delivering presents to an infinite two-dimensional grid of houses.\n\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (>), or west (<). After each move, he delivers another present to the house at his new location.\n\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\n\nFor example:\n\n> delivers presents to 2 houses: one at the starting location, and one to the east.\n^>v< delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.\n^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.\nYour puzzle answer was 2565.\n\n--- Part Two ---\nThe next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\n\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\n\nThis year, how many houses receive at least one present?\n\nFor example:\n\n^v delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south.\n^>v< now delivers presents to 3 houses, and Santa and Robo-Santa end up back where they started.\n^v^v^v^v^v now delivers presents to 11 houses, with Santa going one direction and Robo-Santa going the other.\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    const data = try file.readToEndAlloc(std.heap.page_allocator, 1024 * 1024);\n    defer std.heap.page_allocator.free(data);\n\n    var directions = std.mem.trimRight(u8, data, \"\\n\");\n    var visitedHouses = std.AutoHashMap([2]i32, bool).init(std.heap.page_allocator);\n    defer visitedHouses.deinit();\n\n    var xSanta: i32 = 0;\n    var ySanta: i32 = 0;\n    var xRobo: i32 = 0;\n    var yRobo: i32 = 0;\n    var isSantaTurn: bool = true;\n\n    try visitedHouses.put([2]i32{ xSanta, ySanta }, true);\n\n    for (directions) |dir| {\n        var x: *i32 = undefined;\n        var y: *i32 = undefined;\n        if (isSantaTurn) {\n            x = &xSanta;\n            y = &ySanta;\n        } else {\n            x = &xRobo;\n            y = &yRobo;\n        }\n\n        switch (dir) {\n            '^' => y.* += 1, // Move north\n            'v' => y.* -= 1, // Move south\n            '>' => x.* += 1, // Move east\n            '<' => x.* -= 1, // Move west\n            else => {},\n        }\n\n        try visitedHouses.put([2]i32{ x.*, y.* }, true);\n        isSantaTurn = !isSantaTurn;\n    }\n\n    std.debug.print(\"{d}\\n\", .{visitedHouses.count()});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 5: Doesn't He Have Intern-Elves For This? ---\nSanta needs help figuring out which strings in his text file are naughty or nice.\n\nA nice string is one with all of the following properties:\n\nIt contains at least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou.\nIt contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).\nIt does not contain the strings ab, cd, pq, or xy, even if they are part of one of the other requirements.\nFor example:\n\nugknbfddgicrmopn is nice because it has at least three vowels (u...i...o...), a double letter (...dd...), and none of the disallowed substrings.\naaa is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.\njchzalrnumimnmhp is naughty because it has no double letter.\nhaegwjzuvuyypxyu is naughty because it contains the string xy.\ndvszwmarrgswjxmb is naughty because it contains only one vowel.\nHow many strings are nice?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn isNice(s: []const u8) bool {\n    var vowel_count: usize = 0;\n    var double_letter: bool = false;\n    var bad_substring: bool = false;\n\n    var i: usize = 0;\n    while (i < s.len) {\n        if (std.mem.indexOfScalar(u8, \"aeiou\", s[i]) != null) {\n            vowel_count += 1;\n        }\n\n        if (i + 1 < s.len and s[i] == s[i + 1]) {\n            double_letter = true;\n        }\n\n        if (i + 1 < s.len and\n            (std.mem.eql(u8, s[i .. i + 2], \"ab\") or\n             std.mem.eql(u8, s[i .. i + 2], \"cd\") or\n             std.mem.eql(u8, s[i .. i + 2], \"pq\") or\n             std.mem.eql(u8, s[i .. i + 2], \"xy\")))\n        {\n            bad_substring = true;\n            break;\n        }\n\n        i += 1;\n    }\n\n    return vowel_count >= 3 and double_letter and !bad_substring;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_reader = reader.reader();\n\n    var nice_count: usize = 0;\n\n    var buffer: [1024]u8 = undefined;\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        const trimmed_line = std.mem.trim(u8, line, \"\\n\");\n        if (isNice(trimmed_line)) {\n            nice_count += 1;\n        }\n    }\n\n    std.debug.print(\"{d}\\n\", .{nice_count});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 8: Matchsticks ---\nSpace on the sleigh is limited this year, and so Santa will be bringing his list as a digital copy. He needs to know how much space it will take up when stored.\n\nIt is common in many programming languages to provide a way to escape special characters in strings. For example, C, JavaScript, Perl, Python, and even PHP handle special characters in very similar ways.\n\nHowever, it is important to realize the difference between the number of characters in the code representation of the string literal and the number of characters in the in-memory string itself.\n\nFor example:\n\n\"\" is 2 characters of code (the two double quotes), but the string contains zero characters.\n\"abc\" is 5 characters of code, but 3 characters in the string data.\n\"aaa\\\"aaa\" is 10 characters of code, but the string itself contains six \"a\" characters and a single, escaped quote character, for a total of 7 characters in the string data.\n\"\\x27\" is 6 characters of code, but the string itself contains just one - an apostrophe ('), escaped using hexadecimal notation.\nSanta's list is a file that contains many double-quoted string literals, one on each line. The only escape sequences used are \\\\ (which represents a single backslash), \\\" (which represents a lone double-quote character), and \\x plus two hexadecimal characters (which represents a single character with that ASCII code).\n\nDisregarding the whitespace in the file, what is the number of characters of code for string literals minus the number of characters in memory for the values of the strings in total for the entire file?\n\nFor example, given the four strings above, the total number of characters of string code (2 + 5 + 10 + 6 = 23) minus the total number of characters in memory for string values (0 + 3 + 7 + 1 = 11) is 23 - 11 = 12.\n\nYour puzzle answer was 1342.\n\n--- Part Two ---\nNow, let's go the other way. In addition to finding the number of characters of code, you should now encode each code representation as a new string and find the number of characters of the new encoded representation, including the surrounding double quotes.\n\nFor example:\n\n\"\" encodes to \"\\\"\\\"\", an increase from 2 characters to 6.\n\"abc\" encodes to \"\\\"abc\\\"\", an increase from 5 characters to 9.\n\"aaa\\\"aaa\" encodes to \"\\\"aaa\\\\\\\"aaa\\\"\", an increase from 10 characters to 16.\n\"\\x27\" encodes to \"\\\"\\\\x27\\\"\", an increase from 6 characters to 11.\nYour task is to find the total number of characters to represent the newly encoded strings minus the number of characters of code in each original string literal. For example, for the strings above, the total encoded length (6 + 9 + 16 + 11 = 42) minus the characters in the original code representation (23, just like in the first part of this puzzle) is 42 - 23 = 19.\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn part1(input: []const u8) !usize {\n    var total_code_chars: usize = 0;\n    var total_memory_chars: usize = 0;\n    var current_line_index: usize = 0;\n\n    while (current_line_index < input.len) {\n        var line_end_index = current_line_index;\n        while (line_end_index < input.len and input[line_end_index] != '\\n') {\n            line_end_index += 1;\n        }\n\n        const line = input[current_line_index .. line_end_index];\n        total_code_chars += line.len;\n\n        var memory_chars: usize = 0;\n        var i: usize = 1;\n        while (i < line.len - 1) {\n            if (line[i] == '\\\\') {\n                if (line[i + 1] == 'x') {\n                    i += 3;\n                } else {\n                    i += 2;\n                }\n            } else {\n                i += 1;\n            }\n            memory_chars += 1;\n        }\n        total_memory_chars += memory_chars;\n\n        current_line_index = line_end_index + 1;\n    }\n\n    return total_code_chars - total_memory_chars;\n}\n\nfn part2(input: []const u8) !usize {\n    var total_encoded_chars: usize = 0;\n    var total_code_chars: usize = 0;\n    var current_line_index: usize = 0;\n\n    while (current_line_index < input.len) {\n        var line_end_index = current_line_index;\n        while (line_end_index < input.len and input[line_end_index] != '\\n') {\n            line_end_index += 1;\n        }\n\n        const line = input[current_line_index .. line_end_index];\n        total_code_chars += line.len;\n\n        var encoded_chars: usize = 2;\n        for (line) |c| {\n            if (c == '\\\\' or c == '\"') {\n                encoded_chars += 2;\n            } else {\n                encoded_chars += 1;\n            }\n        }\n        total_encoded_chars += encoded_chars;\n\n        current_line_index = line_end_index + 1;\n    }\n\n    return total_encoded_chars - total_code_chars;\n}\n\npub fn main() !void {\n    const file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    const input = try file.readToEndAlloc(std.heap.page_allocator, 1024 * 1024);\n    defer std.heap.page_allocator.free(input);\n\n    std.debug.print(\"Part 1: {}\\n\", .{try part1(input)});\n    std.debug.print(\"Part 2: {}\\n\", .{try part2(input)});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 17: No Such Thing as Too Much ---\nThe elves bought too much eggnog again - 150 liters this time. To fit it all into your refrigerator, you'll need to move it into smaller containers. You take an inventory of the capacities of the available containers.\n\nFor example, suppose you have containers of size 20, 15, 10, 5, and 5 liters. If you need to store 25 liters, there are four ways to do it:\n\n15 and 10\n20 and 5 (the first 5)\n20 and 5 (the second 5)\n15, 5, and 5\nFilling all containers entirely, how many different combinations of containers can exactly fit all 150 liters of eggnog?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn countCombinations(containers: []i32, target: i32, index: usize) i32 {\n    if (target == 0) return 1;\n    if (target < 0 or index >= containers.len) return 0;\n    return countCombinations(containers, target - containers[index], index + 1) +\n           countCombinations(containers, target, index + 1);\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var containers = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer containers.deinit();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var buffer: [1024]u8 = undefined;\n    while (true) {\n        const line = (try in_stream.readUntilDelimiterOrEof(&buffer, '\\n')) orelse break;\n        const size = try std.fmt.parseInt(i32, line, 10);\n        try containers.append(size);\n    }\n\n    std.debug.print(\"{}\\n\", .{countCombinations(containers.items, 150, 0)});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 17: No Such Thing as Too Much ---\nThe elves bought too much eggnog again - 150 liters this time. To fit it all into your refrigerator, you'll need to move it into smaller containers. You take an inventory of the capacities of the available containers.\n\nFor example, suppose you have containers of size 20, 15, 10, 5, and 5 liters. If you need to store 25 liters, there are four ways to do it:\n\n15 and 10\n20 and 5 (the first 5)\n20 and 5 (the second 5)\n15, 5, and 5\nFilling all containers entirely, how many different combinations of containers can exactly fit all 150 liters of eggnog?\n\nYour puzzle answer was 1638.\n\n--- Part Two ---\nWhile playing with all the containers in the kitchen, another load of eggnog arrives! The shipping and receiving department is requesting as many containers as you can spare.\n\nFind the minimum number of containers that can exactly fit all 150 liters of eggnog. How many different ways can you fill that number of containers and still hold exactly 150 litres?\n\nIn the example above, the minimum number of containers was two. There were three ways to use that many containers, and so the answer there would be 3.\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn findCombinations(containers: []i32, target: i32, index: usize, count: usize, minCount: *usize, ways: *usize) void {\n    if (target == 0) {\n        if (minCount.* == 0 or count < minCount.*) {\n            minCount.* = count;\n            ways.* = 1;\n        } else if (count == minCount.*) {\n            ways.* += 1;\n        }\n        return;\n    }\n    if (target < 0 or index >= containers.len) {\n        return;\n    }\n    // Include current container\n    findCombinations(containers, target - containers[index], index + 1, count + 1, minCount, ways);\n    // Exclude current container\n    findCombinations(containers, target, index + 1, count, minCount, ways);\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var containers = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer containers.deinit();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n    var buf: [1024]u8 = undefined;\n    while (try in_stream.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        if (line.len == 0) {\n            break;\n        }\n        const size = try std.fmt.parseInt(i32, line, 10);\n        try containers.append(size);\n    }\n\n    var minCount: usize = 0;\n    var ways: usize = 0;\n    findCombinations(containers.items, 150, 0, 0, &minCount, &ways);\n    std.debug.print(\"{}\\n\", .{ways});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 20: Infinite Elves and Infinite Houses ---\nTo keep the Elves busy, Santa has them deliver some presents by hand, door-to-door. He sends them down a street with infinite houses numbered sequentially: 1, 2, 3, 4, 5, and so on.\n\nEach Elf is assigned a number, too, and delivers presents to houses based on that number:\n\nThe first Elf (number 1) delivers presents to every house: 1, 2, 3, 4, 5, ....\nThe second Elf (number 2) delivers presents to every second house: 2, 4, 6, 8, 10, ....\nElf number 3 delivers presents to every third house: 3, 6, 9, 12, 15, ....\nThere are infinitely many Elves, numbered starting with 1. Each Elf delivers presents equal to ten times his or her number at each house.\n\nSo, the first nine houses on the street end up like this:\n\nHouse 1 got 10 presents.\nHouse 2 got 30 presents.\nHouse 3 got 40 presents.\nHouse 4 got 70 presents.\nHouse 5 got 60 presents.\nHouse 6 got 120 presents.\nHouse 7 got 80 presents.\nHouse 8 got 150 presents.\nHouse 9 got 130 presents.\nThe first house gets 10 presents: it is visited only by Elf 1, which delivers 1 * 10 = 10 presents. The fourth house gets 70 presents, because it is visited by Elves 1, 2, and 4, for a total of 10 + 20 + 40 = 70 presents.\n\nWhat is the lowest house number of the house to get at least as many presents as the number in your puzzle input?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf: [10]u8 = undefined;\n    const n = try file.reader().readAll(&buf);\n    const presents = try std.fmt.parseInt(usize, buf[0 .. n], 10);\n\n    var house: usize = 1;\n    while (true) {\n        var total: usize = 0;\n        var i: usize = 1;\n        while (i * i <= house) {\n            if (house % i == 0) {\n                total += i * 10;\n                if (i * i != house) {\n                    total += (house / i) * 10;\n                }\n            }\n            i += 1;\n        }\n        if (total >= presents) {\n            std.debug.print(\"{}\\n\", .{house});\n            return;\n        }\n        house += 1;\n    }\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 9: Explosives in Cyberspace ---\nWandering around a secure area, you come across a datalink port to a new part of the network. After briefly scanning it for interesting files, you find one file in particular that catches your attention. It's compressed with an experimental format, but fortunately, the documentation for the format is nearby.\n\nThe format compresses a sequence of characters. Whitespace is ignored. To indicate that some sequence should be repeated, a marker is added to the file, like (10x2). To decompress this marker, take the subsequent 10 characters and repeat them 2 times. Then, continue reading the file after the repeated data. The marker itself is not included in the decompressed output.\n\nIf parentheses or other characters appear within the data referenced by a marker, that's okay - treat it like normal data, not a marker, and then resume looking for markers after the decompressed section.\n\nFor example:\n\nADVENT contains no markers and decompresses to itself with no changes, resulting in a decompressed length of 6.\nA(1x5)BC repeats only the B a total of 5 times, becoming ABBBBBC for a decompressed length of 7.\n(3x3)XYZ becomes XYZXYZXYZ for a decompressed length of 9.\nA(2x2)BCD(2x2)EFG doubles the BC and EF, becoming ABCBCDEFEFG for a decompressed length of 11.\n(6x1)(1x3)A simply becomes (1x3)A - the (1x3) looks like a marker, but because it's within a data section of another marker, it is not treated any differently from the A that comes after it. It has a decompressed length of 6.\nX(8x2)(3x3)ABCY becomes X(3x3)ABC(3x3)ABCY (for a decompressed length of 18), because the decompressed data from the (8x2) marker (the (3x3)ABC) is skipped and not processed further.\nWhat is the decompressed length of the file (your puzzle input)? Don't count whitespace.\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn decompress(input: []const u8) !usize {\n    var i: usize = 0;\n    var decompressed_len: usize = 0;\n\n    while (i < input.len) {\n        if (input[i] == '(') {\n            i += 1;\n            var end = i;\n            while (input[end] != ')') {\n                end += 1;\n            }\n            const marker = input[i .. end];\n            i = end + 1;\n\n            const x_index = std.mem.indexOfScalar(u8, marker, 'x').?;\n            const len = try std.fmt.parseInt(usize, marker[0..x_index], 10);\n            const repeat = try std.fmt.parseInt(usize, marker[x_index + 1 ..], 10);\n            decompressed_len += len * repeat;\n            i += len;\n        } else {\n            decompressed_len += 1;\n            i += 1;\n        }\n    }\n\n    return decompressed_len;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buffer: [1024 * 1024]u8 = undefined;\n    const len = try file.readAll(&buffer);\n    const decompressed_len = try decompress(buffer[0..len]);\n    std.debug.print(\"Decompressed length: {}\\n\", .{decompressed_len});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 19: An Elephant Named Joseph ---\nThe Elves contact you over a highly secure emergency channel. Back at the North Pole, the Elves are busy misunderstanding White Elephant parties.\n\nEach Elf brings a present. They all sit in a circle, numbered starting with position 1. Then, starting with the first Elf, they take turns stealing all the presents from the Elf to their left. An Elf with no presents is removed from the circle and does not take turns.\n\nFor example, with five Elves (numbered 1 to 5):\n\n  1\n5   2\n 4 3\nElf 1 takes Elf 2's present.\nElf 2 has no presents and is skipped.\nElf 3 takes Elf 4's present.\nElf 4 has no presents and is also skipped.\nElf 5 takes Elf 1's two presents.\nNeither Elf 1 nor Elf 2 have any presents, so both are skipped.\nElf 3 takes Elf 5's three presents.\nSo, with five Elves, the Elf that sits starting in position 3 gets all the presents.\n\nWith the number of Elves given in your puzzle input, which Elf gets all the presents?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const total_elves = try readInput(\"input.txt\");\n    const winner = findWinningElf(total_elves);\n    std.debug.print(\"{}\\n\", .{winner});\n}\n\nfn readInput(filename: []const u8) !usize {\n    var file = try std.fs.cwd().openFile(filename, .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n    var buf: [100]u8 = undefined;\n    const line = try in_stream.readUntilDelimiterOrEof(&buf, '\\n');\n    if (line) |l| {\n        return try std.fmt.parseInt(usize, l, 10);\n    } else {\n        return error.FailedToReadInput;\n    }\n}\n\nfn findWinningElf(total_elves: usize) usize {\n    var highest_power_of_two: usize = 1;\n    while (highest_power_of_two * 2 <= total_elves) {\n        highest_power_of_two *= 2;\n    }\n    return (total_elves - highest_power_of_two) * 2 + 1;\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 1: Inverse Captcha ---\nThe night before Christmas, one of Santa's Elves calls you in a panic. \"The printer's broken! We can't print the Naughty or Nice List!\" By the time you make it to sub-basement 17, there are only a few minutes until midnight. \"We have a big problem,\" she says; \"there must be almost fifty bugs in this system, but nothing else can print The List. Stand in this square, quick! There's no time to explain; if you can convince them to pay you in stars, you'll be able to--\" She pulls a lever and the world goes blurry.\n\nWhen your eyes can focus again, everything seems a lot more pixelated than before. She must have sent you inside the computer! You check the system clock: 25 milliseconds until midnight. With that much time, you should be able to collect all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day millisecond in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nYou're standing in a room with \"digitization quarantine\" written in LEDs along one wall. The only door is locked, but it includes a small interface. \"Restricted Area - Strictly No Digitized Users Allowed.\"\n\nIt goes on to explain that you may only leave by solving a captcha to prove you're not a human. Apparently, you only get one millisecond to solve the captcha: too fast for a normal human, but it feels like hours to you.\n\nThe captcha requires you to review a sequence of digits (your puzzle input) and find the sum of all digits that match the next digit in the list. The list is circular, so the digit after the last digit is the first digit in the list.\n\nFor example:\n\n1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2) matches the fourth digit.\n1111 produces 4 because each digit (all 1) matches the next.\n1234 produces 0 because no digit matches the next.\n91212129 produces 9 because the only digit that matches the next one is the last digit, 9.\nWhat is the solution to your captcha?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var sum: u32 = 0;\n    var prev_char: u8 = 0;\n    var first_char: u8 = 0;\n\n    while (true) {\n        const char = in_stream.readByte() catch |err| switch (err) {\n            error.EndOfStream => break,\n            else => return err,\n        };\n\n        if (first_char == 0) {\n            first_char = char;\n        }\n\n        if (prev_char != 0 and char == prev_char) {\n            sum += @as(u32, char - '0');\n        }\n\n        prev_char = char;\n    }\n\n    if (prev_char == first_char) {\n        sum += @as(u32, prev_char - '0');\n    }\n\n    std.log.info(\"{}\", .{sum});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 3: Spiral Memory ---\nYou come across an experimental new kind of memory stored on an infinite two-dimensional grid.\n\nEach square on the grid is allocated in a spiral pattern starting at a location marked 1 and then counting up while spiraling outward. For example, the first few squares are allocated like this:\n\n17  16  15  14  13\n18   5   4   3  12\n19   6   1   2  11\n20   7   8   9  10\n21  22  23---> ...\nWhile this is very space-efficient (no squares are skipped), requested data must be carried back to square 1 (the location of the only access port for this memory system) by programs that can only move up, down, left, or right. They always take the shortest path: the Manhattan Distance between the location of the data and square 1.\n\nFor example:\n\nData from square 1 is carried 0 steps, since it's at the access port.\nData from square 12 is carried 3 steps, such as: down, left, left.\nData from square 23 is carried only 2 steps: up twice.\nData from square 1024 must be carried 31 steps.\nHow many steps are required to carry the data from the square identified in your puzzle input all the way to the access port?\n\nYour puzzle answer was 552.\n\n--- Part Two ---\nAs a stress test on the system, the programs here clear the grid and then store the value 1 in square 1. Then, in the same allocation order as shown above, they store the sum of the values in all adjacent squares, including diagonals.\n\nSo, the first few squares' values are chosen as follows:\n\nSquare 1 starts with the value 1.\nSquare 2 has only one adjacent filled square (with value 1), so it also stores 1.\nSquare 3 has both of the above squares as neighbors and stores the sum of their values, 2.\nSquare 4 has all three of the aforementioned squares as neighbors and stores the sum of their values, 4.\nSquare 5 only has the first and fourth squares as neighbors, so it gets the value 5.\nOnce a square is written, its value does not change. Therefore, the first few squares would receive the following values:\n\n147  142  133  122   59\n304    5    4    2   57\n330   10    1    1   54\n351   11   23   25   26\n362  747  806--->   ...\nWhat is the first value written that is larger than your puzzle input?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buffer: [1024]u8 = undefined;\n    const bytes_read = try file.readAll(&buffer);\n    const target = try std.fmt.parseInt(i32, std.mem.trimRight(u8, buffer[0..bytes_read], \"\\n\"), 10);\n\n    var grid = std.AutoHashMap([2]i32, i32).init(std.heap.page_allocator);\n    defer grid.deinit();\n\n    try grid.put([2]i32{ 0, 0 }, 1);\n\n    var x: i32 = 0;\n    var y: i32 = 0;\n    var dx: i32 = 0;\n    var dy: i32 = -1;\n\n    while (true) {\n        // Change direction when reaching a corner\n        if (x == y or (x < 0 and x == -y) or (x > 0 and x == 1 - y)) {\n            const temp = dx;\n            dx = -dy;\n            dy = temp;\n        }\n\n        // Move to the next square\n        x += dx;\n        y += dy;\n\n        // Calculate value for the current square\n        var value: i32 = 0;\n        var dx_offset: i32 = -1;\n        while (dx_offset <= 1) : (dx_offset += 1) {\n            var dy_offset: i32 = -1;\n            while (dy_offset <= 1) : (dy_offset += 1) {\n                const key = [2]i32{ x + dx_offset, y + dy_offset };\n                value += if (grid.contains(key)) grid.get(key).? else 0;\n            }\n        }\n        try grid.put([2]i32{ x, y }, value);\n\n        // Check if value is greater than the target\n        if (value > target) {\n            std.debug.print(\"{}\", .{value});\n            return;\n        }\n    }\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 4: High-Entropy Passphrases ---\nA new system policy has been put in place that requires all accounts to use a passphrase instead of simply a password. A passphrase consists of a series of words (lowercase letters) separated by spaces.\n\nTo ensure security, a valid passphrase must contain no duplicate words.\n\nFor example:\n\naa bb cc dd ee is valid.\naa bb cc dd aa is not valid - the word aa appears more than once.\naa bb cc dd aaa is valid - aa and aaa count as different words.\nThe system's full passphrase list is available as your puzzle input. How many passphrases are valid?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buffer: [1024 * 1024]u8 = undefined;\n    const bytes_read = try file.readAll(&buffer);\n    const input = buffer[0..bytes_read];\n\n    var passphrases = std.mem.split(u8, std.mem.trimRight(u8, input, \"\\n\"), \"\\n\");\n    var validCount: usize = 0;\n\n    while (passphrases.next()) |passphrase| {\n        var words = std.mem.split(u8, std.mem.trimRight(u8, passphrase, \" \"), \" \");\n        var wordSet = std.StringHashMap(void).init(std.heap.page_allocator);\n        defer wordSet.deinit();\n\n        var valid = true;\n        while (words.next()) |word| {\n            if (wordSet.contains(word)) {\n                valid = false;\n                break;\n            }\n            try wordSet.put(word, {});\n        }\n\n        if (valid) {\n            validCount += 1;\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{validCount});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 9: Stream Processing ---\nA large stream blocks your path. According to the locals, it's not safe to cross the stream at the moment because it's full of garbage. You look down at the stream; rather than water, you discover that it's a stream of characters.\n\nYou sit for a while and record part of the stream (your puzzle input). The characters represent groups - sequences that begin with { and end with }. Within a group, there are zero or more other things, separated by commas: either another group or garbage. Since groups can contain other groups, a } only closes the most-recently-opened unclosed group - that is, they are nestable. Your puzzle input represents a single, large group which itself contains many smaller ones.\n\nSometimes, instead of a group, you will find garbage. Garbage begins with < and ends with >. Between those angle brackets, almost any character can appear, including { and }. Within garbage, < has no special meaning.\n\nIn a futile attempt to clean up the garbage, some program has canceled some of the characters within it using !: inside garbage, any character that comes after ! should be ignored, including <, >, and even another !.\n\nYou don't see any characters that deviate from these rules. Outside garbage, you only find well-formed groups, and garbage always terminates according to the rules above.\n\nHere are some self-contained pieces of garbage:\n\n<>, empty garbage.\n<random characters>, garbage containing random characters.\n<<<<>, because the extra < are ignored.\n<{!>}>, because the first > is canceled.\n<!!>, because the second ! is canceled, allowing the > to terminate the garbage.\n<!!!>>, because the second ! and the first > are canceled.\n<{o\"i!a,<{i<a>, which ends at the first >.\nHere are some examples of whole streams and the number of groups they contain:\n\n{}, 1 group.\n{{{}}}, 3 groups.\n{{},{}}, also 3 groups.\n{{{},{},{{}}}}, 6 groups.\n{<{},{},{{}}>}, 1 group (which itself contains garbage).\n{<a>,<a>,<a>,<a>}, 1 group.\n{{<a>},{<a>},{<a>},{<a>}}, 5 groups.\n{{<!>},{<!>},{<!>},{<a>}}, 2 groups (since all but the last > are canceled).\nYour goal is to find the total score for all groups in your input. Each group is assigned a score which is one more than the score of the group that immediately contains it. (The outermost group gets a score of 1.)\n\n{}, score of 1.\n{{{}}}, score of 1 + 2 + 3 = 6.\n{{},{}}, score of 1 + 2 + 2 = 5.\n{{{},{},{{}}}}, score of 1 + 2 + 3 + 3 + 3 + 4 = 16.\n{<a>,<a>,<a>,<a>}, score of 1.\n{{<ab>},{<ab>},{<ab>},{<ab>}}, score of 1 + 2 + 2 + 2 + 2 = 9.\n{{<!!>},{<!!>},{<!!>},{<!!>}}, score of 1 + 2 + 2 + 2 + 2 = 9.\n{{<a!>},{<a!>},{<a!>},{<ab>}}, score of 1 + 2 = 3.\nWhat is the total score for all groups in your input?\n\nYour puzzle answer was 11846.\n\n--- Part Two ---\nNow, you're ready to remove the garbage.\n\nTo prove you've removed it, you need to count all of the characters within the garbage. The leading and trailing < and > don't count, nor do any canceled characters or the ! doing the canceling.\n\n<>, 0 characters.\n<random characters>, 17 characters.\n<<<<>, 3 characters.\n<{!>}>, 2 characters.\n<!!>, 0 characters.\n<!!!>>, 0 characters.\n<{o\"i!a,<{i<a>, 10 characters.\nHow many non-canceled characters are within the garbage in your puzzle input?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    // Step 1: Read Input\n    const file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n    const reader = file.reader();\n\n    // Step 2: Initialize Variables\n    var score: i32 = 0;\n    var depth: i32 = 0;\n    var in_garbage: bool = false;\n    var cancel_next: bool = false;\n    var garbage_count: i32 = 0;\n\n    // Step 3: Process Stream\n    var buf: [1024]u8 = undefined;\n    while (true) {\n        const bytes_read = try reader.read(&buf);\n        if (bytes_read == 0) break;\n        for (buf[0..bytes_read]) |ch| {\n            if (cancel_next) {\n                cancel_next = false;\n                continue;\n            }\n\n            if (in_garbage) {\n                if (ch == '!') {\n                    cancel_next = true;\n                } else if (ch == '>') {\n                    in_garbage = false;\n                } else {\n                    garbage_count += 1;\n                }\n            } else {\n                switch (ch) {\n                    '{' => depth += 1,\n                    '}' => {\n                        score += depth;\n                        depth -= 1;\n                    },\n                    '<' => in_garbage = true,\n                    else => {},\n                }\n            }\n        }\n    }\n\n    // Step 4: Print Results\n    std.debug.print(\"{}\\n\", .{garbage_count});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 13: Packet Scanners ---\nYou need to cross a vast firewall. The firewall consists of several layers, each with a security scanner that moves back and forth across the layer. To succeed, you must not be detected by a scanner.\n\nBy studying the firewall briefly, you are able to record (in your puzzle input) the depth of each layer and the range of the scanning area for the scanner within it, written as depth: range. Each layer has a thickness of exactly 1. A layer at depth 0 begins immediately inside the firewall; a layer at depth 1 would start immediately after that.\n\nFor example, suppose you've recorded the following:\n\n0: 3\n1: 2\n4: 4\n6: 4\nThis means that there is a layer immediately inside the firewall (with range 3), a second layer immediately after that (with range 2), a third layer which begins at depth 4 (with range 4), and a fourth layer which begins at depth 6 (also with range 4). Visually, it might look like this:\n\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\nWithin each layer, a security scanner moves back and forth within its range. Each security scanner starts at the top and moves down until it reaches the bottom, then moves up until it reaches the top, and repeats. A security scanner takes one picosecond to move one step. Drawing scanners as S, the first few picoseconds look like this:\n\n\nPicosecond 0:\n0   1   2   3   4   5   6\n[S] [S] ... ... [S] ... [S]\n[ ] [ ]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\nPicosecond 1:\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\nPicosecond 2:\n0   1   2   3   4   5   6\n[ ] [S] ... ... [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\nPicosecond 3:\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] ... [ ]\n[S] [S]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [S]     [S]\nYour plan is to hitch a ride on a packet about to move through the firewall. The packet will travel along the top of each layer, and it moves at one layer per picosecond. Each picosecond, the packet moves one layer forward (its first move takes it into layer 0), and then the scanners move one step. If there is a scanner at the top of the layer as your packet enters it, you are caught. (If a scanner moves into the top of its layer while you are there, you are not caught: it doesn't have time to notice you before you leave.) If you were to do this in the configuration above, marking your current position with parentheses, your passage through the firewall would look like this:\n\nInitial state:\n0   1   2   3   4   5   6\n[S] [S] ... ... [S] ... [S]\n[ ] [ ]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\nPicosecond 0:\n0   1   2   3   4   5   6\n(S) [S] ... ... [S] ... [S]\n[ ] [ ]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n( ) [ ] ... ... [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n\nPicosecond 1:\n0   1   2   3   4   5   6\n[ ] ( ) ... ... [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] (S) ... ... [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\n\nPicosecond 2:\n0   1   2   3   4   5   6\n[ ] [S] (.) ... [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [ ] (.) ... [ ] ... [ ]\n[S] [S]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [S]     [S]\n\n\nPicosecond 3:\n0   1   2   3   4   5   6\n[ ] [ ] ... (.) [ ] ... [ ]\n[S] [S]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [S]     [S]\n\n0   1   2   3   4   5   6\n[S] [S] ... (.) [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[ ]             [S]     [S]\n              [ ]     [ ]\n\n\nPicosecond 4:\n0   1   2   3   4   5   6\n[S] [S] ... ... ( ) ... [ ]\n[ ] [ ]         [ ]     [ ]\n[ ]             [S]     [S]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [ ] ... ... ( ) ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n\nPicosecond 5:\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] (.) [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [S] ... ... [S] (.) [S]\n[ ] [ ]         [ ]     [ ]\n[S]             [ ]     [ ]\n              [ ]     [ ]\n\n\nPicosecond 6:\n0   1   2   3   4   5   6\n[ ] [S] ... ... [S] ... (S)\n[ ] [ ]         [ ]     [ ]\n[S]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] ... ( )\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\nIn this situation, you are caught in layers 0 and 6, because your packet entered the layer when its scanner was at the top when you entered it. You are not caught in layer 1, since the scanner moved into the top of the layer once you were already there.\n\nThe severity of getting caught on a layer is equal to its depth multiplied by its range. (Ignore layers in which you do not get caught.) The severity of the whole trip is the sum of these values. In the example above, the trip severity is 0*3 + 6*4 = 24.\n\nGiven the details of the firewall you've recorded, if you leave immediately, what is the severity of your whole trip?\n\nYour puzzle answer was 1960.\n\n--- Part Two ---\nNow, you need to pass through the firewall without being caught - easier said than done.\n\nYou can't control the speed of the packet, but you can delay it any number of picoseconds. For each picosecond you delay the packet before beginning your trip, all security scanners move one step. You're not in the firewall during this time; you don't enter layer 0 until you stop delaying the packet.\n\nIn the example above, if you delay 10 picoseconds (picoseconds 0 - 9), you won't get caught:\n\nState after delaying:\n0   1   2   3   4   5   6\n[ ] [S] ... ... [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\nPicosecond 10:\n0   1   2   3   4   5   6\n( ) [S] ... ... [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n( ) [ ] ... ... [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n\nPicosecond 11:\n0   1   2   3   4   5   6\n[ ] ( ) ... ... [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[S] (S) ... ... [S] ... [S]\n[ ] [ ]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n\nPicosecond 12:\n0   1   2   3   4   5   6\n[S] [S] (.) ... [S] ... [S]\n[ ] [ ]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [ ] (.) ... [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n\nPicosecond 13:\n0   1   2   3   4   5   6\n[ ] [ ] ... (.) [ ] ... [ ]\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [S] ... (.) [ ] ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\n\nPicosecond 14:\n0   1   2   3   4   5   6\n[ ] [S] ... ... ( ) ... [ ]\n[ ] [ ]         [ ]     [ ]\n[S]             [S]     [S]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [ ] ... ... ( ) ... [ ]\n[S] [S]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [S]     [S]\n\n\nPicosecond 15:\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] (.) [ ]\n[S] [S]         [ ]     [ ]\n[ ]             [ ]     [ ]\n              [S]     [S]\n\n0   1   2   3   4   5   6\n[S] [S] ... ... [ ] (.) [ ]\n[ ] [ ]         [ ]     [ ]\n[ ]             [S]     [S]\n              [ ]     [ ]\n\n\nPicosecond 16:\n0   1   2   3   4   5   6\n[S] [S] ... ... [ ] ... ( )\n[ ] [ ]         [ ]     [ ]\n[ ]             [S]     [S]\n              [ ]     [ ]\n\n0   1   2   3   4   5   6\n[ ] [ ] ... ... [ ] ... ( )\n[S] [S]         [S]     [S]\n[ ]             [ ]     [ ]\n              [ ]     [ ]\nBecause all smaller delays would get you caught, the fewest number of picoseconds you would need to delay to get through safely is 10.\n\nWhat is the fewest number of picoseconds that you need to delay the packet to pass through the firewall without being caught?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nconst Scanner = struct {\n    range: usize,\n    position: usize,\n    direction: i32,\n};\n\npub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    var firewall = std.AutoHashMap(usize, Scanner).init(allocator);\n    defer firewall.deinit();\n\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var buf: [1024]u8 = undefined;\n    while (try in_stream.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        var iter = std.mem.tokenize(u8, line, \": \");\n        const depth = try std.fmt.parseInt(usize, iter.next().?, 10);\n        const range = try std.fmt.parseInt(usize, iter.next().?, 10);\n        try firewall.put(depth, Scanner{\n            .range = range,\n            .position = 0,\n            .direction = 1,\n        });\n    }\n\n    var delay: usize = 0;\n    while (true) {\n        if (try passThrough(firewall, delay)) {\n            break;\n        }\n        delay += 1;\n    }\n\n    std.debug.print(\"{}\\n\", .{delay});\n}\n\nfn passThrough(firewall: std.AutoHashMap(usize, Scanner), delay: usize) !bool {\n    var iter = firewall.keyIterator();\n    while (iter.next()) |depth| {\n        const scanner = firewall.get(depth.*).?;\n        if ((depth.* + delay) % (2 * (scanner.range - 1)) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 17: Spinlock ---\nSuddenly, whirling in the distance, you notice what looks like a massive, pixelated hurricane: a deadly spinlock. This spinlock isn't just consuming computing power, but memory, too; vast, digital mountains are being ripped from the ground and consumed by the vortex.\n\nIf you don't move quickly, fixing that printer will be the least of your problems.\n\nThis spinlock's algorithm is simple but efficient, quickly consuming everything in its path. It starts with a circular buffer containing only the value 0, which it marks as the current position. It then steps forward through the circular buffer some number of steps (your puzzle input) before inserting the first new value, 1, after the value it stopped on. The inserted value becomes the current position. Then, it steps forward from there the same number of steps, and wherever it stops, inserts after it the second new value, 2, and uses that as the new current position again.\n\nIt repeats this process of stepping forward, inserting a new value, and using the location of the inserted value as the new current position a total of 2017 times, inserting 2017 as its final operation, and ending with a total of 2018 values (including 0) in the circular buffer.\n\nFor example, if the spinlock were to step 3 times per insert, the circular buffer would begin to evolve like this (using parentheses to mark the current position after each iteration of the algorithm):\n\n(0), the initial state before any insertions.\n0 (1): the spinlock steps forward three times (0, 0, 0), and then inserts the first value, 1, after it. 1 becomes the current position.\n0 (2) 1: the spinlock steps forward three times (0, 1, 0), and then inserts the second value, 2, after it. 2 becomes the current position.\n0  2 (3) 1: the spinlock steps forward three times (1, 0, 2), and then inserts the third value, 3, after it. 3 becomes the current position.\nAnd so on:\n\n0  2 (4) 3  1\n0 (5) 2  4  3  1\n0  5  2  4  3 (6) 1\n0  5 (7) 2  4  3  6  1\n0  5  7  2  4  3 (8) 6  1\n0 (9) 5  7  2  4  3  8  6  1\nEventually, after 2017 insertions, the section of the circular buffer near the last insertion looks like this:\n\n1512  1134  151 (2017) 638  1513  851\nPerhaps, if you can identify the value that will ultimately be after the last value written (2017), you can short-circuit the spinlock. In this example, that would be 638.\n\nWhat is the value after 2017 in your completed circular buffer?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    const file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buffer: [1024]u8 = undefined;\n    const n = try file.readAll(&buffer);\n    const input = buffer[0..n];\n    const steps = try std.fmt.parseInt(usize, input, 10);\n\n    var current: usize = 0;\n    var buffer_data = std.ArrayList(usize).init(allocator);\n    defer buffer_data.deinit();\n\n    buffer_data.append(0) catch unreachable;\n\n    var i: usize = 1;\n    while (i <= 2017) : (i += 1) {\n        current = (current + steps) % buffer_data.items.len;\n        buffer_data.insert(current + 1, i) catch unreachable;\n        current += 1;\n    }\n\n    const result = buffer_data.items[(current + 1) % buffer_data.items.len];\n    std.debug.print(\"The value after 2017 is: {}\\n\", .{result});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 17: Spinlock ---\nSuddenly, whirling in the distance, you notice what looks like a massive, pixelated hurricane: a deadly spinlock. This spinlock isn't just consuming computing power, but memory, too; vast, digital mountains are being ripped from the ground and consumed by the vortex.\n\nIf you don't move quickly, fixing that printer will be the least of your problems.\n\nThis spinlock's algorithm is simple but efficient, quickly consuming everything in its path. It starts with a circular buffer containing only the value 0, which it marks as the current position. It then steps forward through the circular buffer some number of steps (your puzzle input) before inserting the first new value, 1, after the value it stopped on. The inserted value becomes the current position. Then, it steps forward from there the same number of steps, and wherever it stops, inserts after it the second new value, 2, and uses that as the new current position again.\n\nIt repeats this process of stepping forward, inserting a new value, and using the location of the inserted value as the new current position a total of 2017 times, inserting 2017 as its final operation, and ending with a total of 2018 values (including 0) in the circular buffer.\n\nFor example, if the spinlock were to step 3 times per insert, the circular buffer would begin to evolve like this (using parentheses to mark the current position after each iteration of the algorithm):\n\n(0), the initial state before any insertions.\n0 (1): the spinlock steps forward three times (0, 0, 0), and then inserts the first value, 1, after it. 1 becomes the current position.\n0 (2) 1: the spinlock steps forward three times (0, 1, 0), and then inserts the second value, 2, after it. 2 becomes the current position.\n0  2 (3) 1: the spinlock steps forward three times (1, 0, 2), and then inserts the third value, 3, after it. 3 becomes the current position.\nAnd so on:\n\n0  2 (4) 3  1\n0 (5) 2  4  3  1\n0  5  2  4  3 (6) 1\n0  5 (7) 2  4  3  6  1\n0  5  7  2  4  3 (8) 6  1\n0 (9) 5  7  2  4  3  8  6  1\nEventually, after 2017 insertions, the section of the circular buffer near the last insertion looks like this:\n\n1512  1134  151 (2017) 638  1513  851\nPerhaps, if you can identify the value that will ultimately be after the last value written (2017), you can short-circuit the spinlock. In this example, that would be 638.\n\nWhat is the value after 2017 in your completed circular buffer?\n\nYour puzzle answer was 1914.\n\n--- Part Two ---\nThe spinlock does not short-circuit. Instead, it gets more angry. At least, you assume that's what happened; it's spinning significantly faster than it was a moment ago.\n\nYou have good news and bad news.\n\nThe good news is that you have improved calculations for how to stop the spinlock. They indicate that you actually need to identify the value after 0 in the current state of the circular buffer.\n\nThe bad news is that while you were determining this, the spinlock has just finished inserting its fifty millionth value (50000000).\n\nWhat is the value after 0 the moment 50000000 is inserted?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buffer: [100]u8 = undefined;\n    const bytes_read = try file.readAll(&buffer);\n    const steps = try std.fmt.parseInt(usize, buffer[0 .. bytes_read], 10);\n\n    var current_pos: usize = 0;\n    var value_after_zero: usize = 0;\n\n    for (0 .. 50_000_000) |i| {\n        current_pos = (current_pos + steps) % (i + 1);\n        if (current_pos == 0) {\n            value_after_zero = i + 1;\n        }\n        current_pos += 1;\n    }\n\n    std.debug.print(\"{}\\n\", .{value_after_zero});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 1: Chronal Calibration ---\n\"We've detected some temporal anomalies,\" one of Santa's Elves at the Temporal Anomaly Research and Detection Instrument Station tells you. She sounded pretty worried when she called you down here. \"At 500-year intervals into the past, someone has been changing Santa's history!\"\n\n\"The good news is that the changes won't propagate to our time stream for another 25 days, and we have a device\" - she attaches something to your wrist - \"that will let you fix the changes with no such propagation delay. It's configured to send you 500 years further into the past every few days; that was the best we could do on such short notice.\"\n\n\"The bad news is that we are detecting roughly fifty anomalies throughout time; the device will indicate fixed anomalies with stars. The other bad news is that we only have one device and you're the best person for the job! Good lu--\" She taps a button on the device and you suddenly feel like you're falling. To save Christmas, you need to get all fifty stars by December 25th.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nAfter feeling like you've been falling for a few minutes, you look at the device's tiny screen. \"Error: Device must be calibrated before first use. Frequency drift detected. Cannot maintain destination lock.\" Below the message, the device shows a sequence of changes in frequency (your puzzle input). A value like +6 means the current frequency increases by 6; a value like -3 means the current frequency decreases by 3.\n\nFor example, if the device displays frequency changes of +1, -2, +3, +1, then starting from a frequency of zero, the following changes would occur:\n\nCurrent frequency  0, change of +1; resulting frequency  1.\nCurrent frequency  1, change of -2; resulting frequency -1.\nCurrent frequency -1, change of +3; resulting frequency  2.\nCurrent frequency  2, change of +1; resulting frequency  3.\nIn this example, the resulting frequency is 3.\n\nHere are other example situations:\n\n+1, +1, +1 results in  3\n+1, +1, -2 results in  0\n-1, -2, -3 results in -6\nStarting with a frequency of zero, what is the resulting frequency after all of the changes in frequency have been applied?\n\nYour puzzle answer was 406.\n\n--- Part Two ---\nYou notice that the device repeats the same frequency change list over and over. To calibrate the device, you need to find the first frequency it reaches twice.\n\nFor example, using the same list of changes above, the device would loop as follows:\n\nCurrent frequency  0, change of +1; resulting frequency  1.\nCurrent frequency  1, change of -2; resulting frequency -1.\nCurrent frequency -1, change of +3; resulting frequency  2.\nCurrent frequency  2, change of +1; resulting frequency  3.\n(At this point, the device continues from the start of the list.)\nCurrent frequency  3, change of +1; resulting frequency  4.\nCurrent frequency  4, change of -2; resulting frequency  2, which has already been seen.\nIn this example, the first frequency reached twice is 2. Note that your device might need to repeat its list of frequency changes many times before a duplicate frequency is found, and that duplicates might be found while in the middle of processing the list.\n\nHere are other examples:\n\n+1, -1 first reaches 0 twice.\n+3, +3, +4, -2, -4 first reaches 10 twice.\n-6, +3, +8, +5, -6 first reaches 5 twice.\n+7, +7, -2, -7, -4 first reaches 14 twice.\nWhat is the first frequency your device reaches twice?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_reader = reader.reader();\n\n    var frequency_changes = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer frequency_changes.deinit();\n\n    var buffer: [1024]u8 = undefined;\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        if (line.len == 0) continue;\n        const frequency_delta = try std.fmt.parseInt(i32, line, 10);\n        try frequency_changes.append(frequency_delta);\n    }\n\n    var frequencies = std.AutoHashMap(i32, void).init(std.heap.page_allocator);\n    defer frequencies.deinit();\n\n    var current_frequency: i32 = 0;\n    try frequencies.put(current_frequency, {});\n\n    while (true) {\n        for (frequency_changes.items) |change| {\n            current_frequency += change;\n            if (frequencies.contains(current_frequency)) {\n                std.debug.print(\"{}\\n\", .{current_frequency});\n                return;\n            }\n            try frequencies.put(current_frequency, {});\n        }\n    }\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: Inventory Management System ---\nYou stop falling through time, catch your breath, and check the screen on the device. \"Destination reached. Current Year: 1518. Current Location: North Pole Utility Closet 83N10.\" You made it! Now, to find those anomalies.\n\nOutside the utility closet, you hear footsteps and a voice. \"...I'm not sure either. But now that so many people have chimneys, maybe he could sneak in that way?\" Another voice responds, \"Actually, we've been working on a new kind of suit that would let him fit through tight spaces like that. But, I heard that a few days ago, they lost the prototype fabric, the design plans, everything! Nobody on the team can even seem to remember important details of the project!\"\n\n\"Wouldn't they have had enough fabric to fill several boxes in the warehouse? They'd be stored together, so the box IDs should be similar. Too bad it would take forever to search the warehouse for two similar box IDs...\" They walk too far away to hear any more.\n\nLate at night, you sneak to the warehouse - who knows what kinds of paradoxes you could cause if you were discovered - and use your fancy wrist device to quickly scan every box and produce a list of the likely candidates (your puzzle input).\n\nTo make sure you didn't miss any, you scan the likely candidate boxes again, counting the number that have an ID containing exactly two of any letter and then separately counting those with exactly three of any letter. You can multiply those two counts together to get a rudimentary checksum and compare it to what your device predicts.\n\nFor example, if you see the following box IDs:\n\nabcdef contains no letters that appear exactly two or three times.\nbababc contains two a and three b, so it counts for both.\nabbcde contains two b, but no letter appears exactly three times.\nabcccd contains three c, but no letter appears exactly two times.\naabcdd contains two a and two d, but it only counts once.\nabcdee contains two e.\nababab contains three a and three b, but it only counts once.\nOf these box IDs, four of them contain a letter which appears exactly twice, and three of them contain a letter which appears exactly three times. Multiplying these together produces a checksum of 4 * 3 = 12.\n\nWhat is the checksum for your list of box IDs?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_reader = reader.reader();\n\n    var twos_count: i32 = 0;\n    var threes_count: i32 = 0;\n\n    var buffer: [1024]u8 = undefined;\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        var letter_counts = [_]i32{0} ** 26;\n\n        for (line) |char| {\n            const idx = char - 'a';\n            if (idx >= 0 and idx < 26) {\n                letter_counts[idx] += 1;\n            }\n        }\n\n        var found_twos: bool = false;\n        var found_threes: bool = false;\n\n        for (letter_counts) |count| {\n            if (count == 2) found_twos = true;\n            if (count == 3) found_threes = true;\n        }\n\n        if (found_twos) twos_count += 1;\n        if (found_threes) threes_count += 1;\n    }\n\n    const checksum = twos_count * threes_count;\n    std.debug.print(\"{}\\n\", .{checksum});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 1: The Tyranny of the Rocket Equation ---\nSanta has become stranded at the edge of the Solar System while delivering presents to other planets! To accurately calculate his position in space, safely align his warp drive, and return to Earth in time to save Christmas, he needs you to bring him measurements from fifty stars.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nThe Elves quickly load you into a spacecraft and prepare to launch.\n\nAt the first Go / No Go poll, every Elf is Go until the Fuel Counter-Upper. They haven't determined the amount of fuel required yet.\n\nFuel required to launch a given module is based on its mass. Specifically, to find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.\n\nFor example:\n\nFor a mass of 12, divide by 3 and round down to get 4, then subtract 2 to get 2.\nFor a mass of 14, dividing by 3 and rounding down still yields 4, so the fuel required is also 2.\nFor a mass of 1969, the fuel required is 654.\nFor a mass of 100756, the fuel required is 33583.\nThe Fuel Counter-Upper needs to know the total fuel requirement. To find it, individually calculate the fuel needed for the mass of each module (your puzzle input), then add together all the fuel values.\n\nWhat is the sum of the fuel requirements for all of the modules on your spacecraft?\n\nYour puzzle answer was 3465154.\n\n--- Part Two ---\nDuring the second Go / No Go poll, the Elf in charge of the Rocket Equation Double-Checker stops the launch sequence. Apparently, you forgot to include additional fuel for the fuel you just added.\n\nFuel itself requires fuel just like a module - take its mass, divide by three, round down, and subtract 2. However, that fuel also requires fuel, and that fuel requires fuel, and so on. Any mass that would require negative fuel should instead be treated as if it requires zero fuel; the remaining mass, if any, is instead handled by wishing really hard, which has no mass and is outside the scope of this calculation.\n\nSo, for each module mass, calculate its fuel and add it to the total. Then, treat the fuel amount you just calculated as the input mass and repeat the process, continuing until a fuel requirement is zero or negative. For example:\n\nA module of mass 14 requires 2 fuel. This fuel requires no further fuel (2 divided by 3 and rounded down is 0, which would call for a negative fuel), so the total fuel required is still just 2.\nAt first, a module of mass 1969 requires 654 fuel. Then, this fuel requires 216 more fuel (654 / 3 - 2). 216 then requires 70 more fuel, which requires 21 fuel, which requires 5 fuel, which requires no further fuel. So, the total fuel required for a module of mass 1969 is 654 + 216 + 70 + 21 + 5 = 966.\nThe fuel required by a module of mass 100756 and its fuel is: 33583 + 11192 + 3728 + 1240 + 411 + 135 + 43 + 12 + 2 = 50346.\nWhat is the sum of the fuel requirements for all of the modules on your spacecraft when also taking into account the mass of the added fuel? (Calculate the fuel requirements for each module separately, then add them all up at the end.)\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn calculateFuel(mass: i32) i32 {\n    const fuelRequired = @divTrunc(mass, 3) - 2;\n    return @max(fuelRequired, 0);\n}\n\nfn calculateTotalFuel(mass: i32) i32 {\n    var totalFuel: i32 = 0;\n    var currentFuel = calculateFuel(mass);\n    while (currentFuel > 0) {\n        totalFuel += currentFuel;\n        currentFuel = calculateFuel(currentFuel);\n    }\n    return totalFuel;\n}\n\npub fn main() !void {\n    const file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var totalFuel: i32 = 0;\n    var buf: [1024]u8 = undefined;\n    while (try file.reader().readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        const mass = try std.fmt.parseInt(i32, line, 10);\n        totalFuel += calculateTotalFuel(mass);\n    }\n\n    std.debug.print(\"{}\\n\", .{totalFuel});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 8: Space Image Format ---\nThe Elves' spirits are lifted when they realize you have an opportunity to reboot one of their Mars rovers, and so they are curious if you would spend a brief sojourn on Mars. You land your ship near the rover.\n\nWhen you reach the rover, you discover that it's already in the process of rebooting! It's just waiting for someone to enter a BIOS password. The Elf responsible for the rover takes a picture of the password (your puzzle input) and sends it to you via the Digital Sending Network.\n\nUnfortunately, images sent via the Digital Sending Network aren't encoded with any normal encoding; instead, they're encoded in a special Space Image Format. None of the Elves seem to remember why this is the case. They send you the instructions to decode it.\n\nImages are sent as a series of digits that each represent the color of a single pixel. The digits fill each row of the image left-to-right, then move downward to the next row, filling rows top-to-bottom until every pixel of the image is filled.\n\nEach image actually consists of a series of identically-sized layers that are filled in this way. So, the first digit corresponds to the top-left pixel of the first layer, the second digit corresponds to the pixel to the right of that on the same layer, and so on until the last digit, which corresponds to the bottom-right pixel of the last layer.\n\nFor example, given an image 3 pixels wide and 2 pixels tall, the image data 123456789012 corresponds to the following image layers:\n\nLayer 1: 123\n         456\n\nLayer 2: 789\n         012\nThe image you received is 25 pixels wide and 6 pixels tall.\n\nTo make sure the image wasn't corrupted during transmission, the Elves would like you to find the layer that contains the fewest 0 digits. On that layer, what is the number of 1 digits multiplied by the number of 2 digits?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn min(a: usize, b: usize) usize {\n    return if (a < b) a else b;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    const data = try file.readToEndAlloc(std.heap.page_allocator, 1024 * 1024);\n    defer std.heap.page_allocator.free(data);\n\n    const width: usize = 25;\n    const height: usize = 6;\n    const layerSize: usize = width * height;\n\n    var minZeros: usize = layerSize + 1;\n    var result: usize = 0;\n\n    var i: usize = 0;\n    while (i < data.len) : (i += layerSize) {\n        const layer = data[i .. min(i + layerSize, data.len)];\n        var zeroCount: usize = 0;\n        var oneCount: usize = 0;\n        var twoCount: usize = 0;\n\n        for (layer) |pixel| {\n            switch (pixel) {\n                '0' => zeroCount += 1,\n                '1' => oneCount += 1,\n                '2' => twoCount += 1,\n                else => {},\n            }\n        }\n\n        if (zeroCount < minZeros) {\n            minZeros = zeroCount;\n            result = oneCount * twoCount;\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{result});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: Password Philosophy ---\nYour flight departs in a few days from the coastal airport; the easiest way down to the coast from here is via toboggan.\n\nThe shopkeeper at the North Pole Toboggan Rental Shop is having a bad day. \"Something's wrong with our computers; we can't log in!\" You ask if you can take a look.\n\nTheir password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen.\n\nTo try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set.\n\nFor example, suppose you have the following list:\n\n1-3 a: abcde\n1-3 b: cdefg\n2-9 c: ccccccccc\nEach line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.\n\nIn the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies.\n\nHow many passwords are valid according to their policies?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn validatePassword(policy: []const u8, password: []const u8) bool {\n    var min: usize = 0;\n    var max: usize = 0;\n    var char: u8 = 0;\n    var count: usize = 0;\n\n    var i: usize = 0;\n    while (i < policy.len and policy[i] != '-') : (i += 1) {\n        min = min * 10 + policy[i] - '0';\n    }\n    i += 1;\n    while (i < policy.len and policy[i] != ' ') : (i += 1) {\n        max = max * 10 + policy[i] - '0';\n    }\n    i += 1;\n    char = policy[i];\n\n    for (password) |c| {\n        if (c == char) {\n            count += 1;\n        }\n    }\n\n    return count >= min and count <= max;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_buf: [1024]u8 = undefined;\n    var line_stream = reader.reader();\n\n    var validCount: usize = 0;\n    while (try line_stream.readUntilDelimiterOrEof(&line_buf, '\\n')) |line| {\n        if (std.mem.indexOfScalar(u8, line, ':')) |i| {\n            const policy = line[0..i];\n            const password = line[i + 2 ..];\n            if (validatePassword(policy, password)) {\n                validCount += 1;\n            }\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{validCount});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: Password Philosophy ---\nYour flight departs in a few days from the coastal airport; the easiest way down to the coast from here is via toboggan.\n\nThe shopkeeper at the North Pole Toboggan Rental Shop is having a bad day. \"Something's wrong with our computers; we can't log in!\" You ask if you can take a look.\n\nTheir password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen.\n\nTo try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set.\n\nFor example, suppose you have the following list:\n\n1-3 a: abcde\n1-3 b: cdefg\n2-9 c: ccccccccc\nEach line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.\n\nIn the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies.\n\nHow many passwords are valid according to their policies?\n\nYour puzzle answer was 519.\n\n--- Part Two ---\nWhile it appears you validated the passwords correctly, they don't seem to be what the Official Toboggan Corporate Authentication System is expecting.\n\nThe shopkeeper suddenly realizes that he just accidentally explained the password policy rules from his old job at the sled rental place down the street! The Official Toboggan Corporate Policy actually works a little differently.\n\nEach policy actually describes two positions in the password, where 1 means the first character, 2 means the second character, and so on. (Be careful; Toboggan Corporate Policies have no concept of \"index zero\"!) Exactly one of these positions must contain the given letter. Other occurrences of the letter are irrelevant for the purposes of policy enforcement.\n\nGiven the same example list from above:\n\n1-3 a: abcde is valid: position 1 contains a and position 3 does not.\n1-3 b: cdefg is invalid: neither position 1 nor position 3 contains b.\n2-9 c: ccccccccc is invalid: both position 2 and position 9 contain c.\nHow many passwords are valid according to the new interpretation of the policies?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn validatePassword(policy: []const u8, password: []const u8) bool {\n    var min: usize = 0;\n    var max: usize = 0;\n    var char: u8 = 0;\n    var i: usize = 0;\n    while (i < policy.len and policy[i] != '-') : (i += 1) {\n        min = min * 10 + policy[i] - '0';\n    }\n    i += 1;\n    while (i < policy.len and policy[i] != ' ') : (i += 1) {\n        max = max * 10 + policy[i] - '0';\n    }\n    i += 1;\n    char = policy[i];\n    return (password[min - 1] == char) != (password[max - 1] == char);\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var buffer: [1024]u8 = undefined;\n    var validCount: usize = 0;\n\n    while (try reader.reader().readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        if (std.mem.indexOfScalar(u8, line, ':')) |i| {\n            const policy = line[0..i];\n            const password = line[i + 2 ..];\n            if (validatePassword(policy, password)) {\n                validCount += 1;\n            }\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{validCount});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 12: Rain Risk ---\nYour ferry made decent progress toward the island, but the storm came in faster than anyone expected. The ferry needs to take evasive actions!\n\nUnfortunately, the ship's navigation computer seems to be malfunctioning; rather than giving a route directly to safety, it produced extremely circuitous instructions. When the captain uses the PA system to ask if anyone can help, you quickly volunteer.\n\nThe navigation instructions (your puzzle input) consists of a sequence of single-character actions paired with integer input values. After staring at them for a few minutes, you work out what they probably mean:\n\nAction N means to move north by the given value.\nAction S means to move south by the given value.\nAction E means to move east by the given value.\nAction W means to move west by the given value.\nAction L means to turn left the given number of degrees.\nAction R means to turn right the given number of degrees.\nAction F means to move forward by the given value in the direction the ship is currently facing.\nThe ship starts by facing east. Only the L and R actions change the direction the ship is facing. (That is, if the ship is facing east and the next instruction is N10, the ship would move north 10 units, but would still move east if the following action were F.)\n\nFor example:\n\nF10\nN3\nF7\nR90\nF11\nThese instructions would be handled as follows:\n\nF10 would move the ship 10 units east (because the ship starts by facing east) to east 10, north 0.\nN3 would move the ship 3 units north to east 10, north 3.\nF7 would move the ship another 7 units east (because the ship is still facing east) to east 17, north 3.\nR90 would cause the ship to turn right by 90 degrees and face south; it remains at east 17, north 3.\nF11 would move the ship 11 units south to east 17, south 8.\nAt the end of these instructions, the ship's Manhattan distance (sum of the absolute values of its east/west position and its north/south position) from its starting position is 17 + 8 = 25.\n\nFigure out where the navigation instructions lead. What is the Manhattan distance between that location and the ship's starting position?\n\nYour puzzle answer was 381.\n\n--- Part Two ---\nBefore you can give the destination to the captain, you realize that the actual action meanings were printed on the back of the instructions the whole time.\n\nAlmost all of the actions indicate how to move a waypoint which is relative to the ship's position:\n\nAction N means to move the waypoint north by the given value.\nAction S means to move the waypoint south by the given value.\nAction E means to move the waypoint east by the given value.\nAction W means to move the waypoint west by the given value.\nAction L means to rotate the waypoint around the ship left (counter-clockwise) the given number of degrees.\nAction R means to rotate the waypoint around the ship right (clockwise) the given number of degrees.\nAction F means to move forward to the waypoint a number of times equal to the given value.\nThe waypoint starts 10 units east and 1 unit north relative to the ship. The waypoint is relative to the ship; that is, if the ship moves, the waypoint moves with it.\n\nFor example, using the same instructions as above:\n\nF10 moves the ship to the waypoint 10 times (a total of 100 units east and 10 units north), leaving the ship at east 100, north 10. The waypoint stays 10 units east and 1 unit north of the ship.\nN3 moves the waypoint 3 units north to 10 units east and 4 units north of the ship. The ship remains at east 100, north 10.\nF7 moves the ship to the waypoint 7 times (a total of 70 units east and 28 units north), leaving the ship at east 170, north 38. The waypoint stays 10 units east and 4 units north of the ship.\nR90 rotates the waypoint around the ship clockwise 90 degrees, moving it to 4 units east and 10 units south of the ship. The ship remains at east 170, north 38.\nF11 moves the ship to the waypoint 11 times (a total of 44 units east and 110 units south), leaving the ship at east 214, south 72. The waypoint stays 4 units east and 10 units south of the ship.\nAfter these operations, the ship's Manhattan distance from its starting position is 214 + 72 = 286.\n\nFigure out where the navigation instructions actually lead. What is the Manhattan distance between that location and the ship's starting position?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nconst Ship = struct {\n    x: i32,\n    y: i32,\n    waypoint_x: i32,\n    waypoint_y: i32,\n\n    fn processInstruction(self: *Ship, action: u8, value: i32) void {\n        switch (action) {\n            'N' => self.waypoint_y += value,\n            'S' => self.waypoint_y -= value,\n            'E' => self.waypoint_x += value,\n            'W' => self.waypoint_x -= value,\n            'L' => self.rotateWaypoint(-value),\n            'R' => self.rotateWaypoint(value),\n            'F' => {\n                self.x += self.waypoint_x * value;\n                self.y += self.waypoint_y * value;\n            },\n            else => {},\n        }\n    }\n\n    fn rotateWaypoint(self: *Ship, degrees: i32) void {\n        const d = @mod((degrees + 360), 360);\n        switch (d) {\n            90 => {\n                const temp = self.waypoint_x;\n                self.waypoint_x = self.waypoint_y;\n                self.waypoint_y = -temp;\n            },\n            180 => {\n                self.waypoint_x = -self.waypoint_x;\n                self.waypoint_y = -self.waypoint_y;\n            },\n            270 => {\n                const temp = self.waypoint_x;\n                self.waypoint_x = -self.waypoint_y;\n                self.waypoint_y = temp;\n            },\n            else => {},\n        }\n    }\n};\n\nfn abs(x: i32) i32 {\n    return if (x < 0) -x else x;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var ship = Ship{ .x = 0, .y = 0, .waypoint_x = 10, .waypoint_y = 1 };\n\n    var buf: [1024]u8 = undefined;\n    while (try in_stream.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        const action = line[0];\n        const value = try std.fmt.parseInt(i32, line[1 .. line.len], 10);\n        ship.processInstruction(action, value);\n    }\n\n    const manhattan_distance = abs(ship.x) + abs(ship.y);\n    std.debug.print(\"{}\\n\", .{manhattan_distance});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 15: Rambunctious Recitation ---\nYou catch the airport shuttle and try to book a new flight to your vacation island. Due to the storm, all direct flights have been cancelled, but a route is available to get around the storm. You take it.\n\nWhile you wait for your flight, you decide to check in with the Elves back at the North Pole. They're playing a memory game and are ever so excited to explain the rules!\n\nIn this game, the players take turns saying numbers. They begin by taking turns reading from a list of starting numbers (your puzzle input). Then, each turn consists of considering the most recently spoken number:\n\nIf that was the first time the number has been spoken, the current player says 0.\nOtherwise, the number had been spoken before; the current player announces how many turns apart the number is from when it was previously spoken.\nSo, after the starting numbers, each turn results in that player speaking aloud either 0 (if the last number is new) or an age (if the last number is a repeat).\n\nFor example, suppose the starting numbers are 0,3,6:\n\nTurn 1: The 1st number spoken is a starting number, 0.\nTurn 2: The 2nd number spoken is a starting number, 3.\nTurn 3: The 3rd number spoken is a starting number, 6.\nTurn 4: Now, consider the last number spoken, 6. Since that was the first time the number had been spoken, the 4th number spoken is 0.\nTurn 5: Next, again consider the last number spoken, 0. Since it had been spoken before, the next number to speak is the difference between the turn number when it was last spoken (the previous turn, 4) and the turn number of the time it was most recently spoken before then (turn 1). Thus, the 5th number spoken is 4 - 1, 3.\nTurn 6: The last number spoken, 3 had also been spoken before, most recently on turns 5 and 2. So, the 6th number spoken is 5 - 2, 3.\nTurn 7: Since 3 was just spoken twice in a row, and the last two turns are 1 turn apart, the 7th number spoken is 1.\nTurn 8: Since 1 is new, the 8th number spoken is 0.\nTurn 9: 0 was last spoken on turns 8 and 4, so the 9th number spoken is the difference between them, 4.\nTurn 10: 4 is new, so the 10th number spoken is 0.\n(The game ends when the Elves get sick of playing or dinner is ready, whichever comes first.)\n\nTheir question for you is: what will be the 2020th number spoken? In the example above, the 2020th number spoken will be 436.\n\nHere are a few more examples:\n\nGiven the starting numbers 1,3,2, the 2020th number spoken is 1.\nGiven the starting numbers 2,1,3, the 2020th number spoken is 10.\nGiven the starting numbers 1,2,3, the 2020th number spoken is 27.\nGiven the starting numbers 2,3,1, the 2020th number spoken is 78.\nGiven the starting numbers 3,2,1, the 2020th number spoken is 438.\nGiven the starting numbers 3,1,2, the 2020th number spoken is 1836.\nGiven your starting numbers, what will be the 2020th number spoken?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buffer: [1024]u8 = undefined;\n    const bytes_read = try file.readAll(&buffer);\n    const input = buffer[0..bytes_read];\n\n    var starting_numbers = std.mem.tokenize(u8, input, \",\");\n    var last_spoken = std.AutoHashMap(i32, i32).init(std.heap.page_allocator);\n    defer last_spoken.deinit();\n\n    var last_number: i32 = 0;\n    var next_number: i32 = 0;\n    var turn: i32 = 1;\n\n    // Iterate through the starting numbers\n    while (starting_numbers.next()) |num| {\n        last_number = try std.fmt.parseInt(i32, num, 10);\n        try last_spoken.put(last_number, turn);\n        turn += 1;\n    }\n\n    while (turn <= 2020) : (turn += 1) {\n        if (last_spoken.get(last_number)) |last_turn| {\n            next_number = turn - 1 - last_turn;\n        } else {\n            next_number = 0;\n        }\n\n        try last_spoken.put(last_number, turn - 1);\n        last_number = next_number;\n    }\n\n    std.debug.print(\"{}\\n\", .{last_number});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 18: Operation Order ---\nAs you look out the window and notice a heavily-forested continent slowly appear over the horizon, you are interrupted by the child sitting next to you. They're curious if you could help them with their math homework.\n\nUnfortunately, it seems like this \"math\" follows different rules than you remember.\n\nThe homework (your puzzle input) consists of a series of expressions that consist of addition (+), multiplication (*), and parentheses ((...)). Just like normal math, parentheses indicate that the expression inside must be evaluated before it can be used by the surrounding expression. Addition still finds the sum of the numbers on both sides of the operator, and multiplication still finds the product.\n\nHowever, the rules of operator precedence have changed. Rather than evaluating multiplication before addition, the operators have the same precedence, and are evaluated left-to-right regardless of the order in which they appear.\n\nFor example, the steps to evaluate the expression 1 + 2 * 3 + 4 * 5 + 6 are as follows:\n\n1 + 2 * 3 + 4 * 5 + 6\n  3   * 3 + 4 * 5 + 6\n      9   + 4 * 5 + 6\n         13   * 5 + 6\n             65   + 6\n                 71\nParentheses can override this order; for example, here is what happens if parentheses are added to form 1 + (2 * 3) + (4 * (5 + 6)):\n\n1 + (2 * 3) + (4 * (5 + 6))\n1 +    6    + (4 * (5 + 6))\n     7      + (4 * (5 + 6))\n     7      + (4 *   11   )\n     7      +     44\n            51\nHere are a few more examples:\n\n2 * 3 + (4 * 5) becomes 26.\n5 + (8 * 3 + 9 + 3 * 4 * 3) becomes 437.\n5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) becomes 12240.\n((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 becomes 13632.\nBefore you can help with the homework, you need to understand it yourself. Evaluate the expression on each line of the homework; what is the sum of the resulting values?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn parseExpression(input: []const u8) i64 {\n    var result: i64 = 0;\n    var op: ?u8 = null;\n    var num: i64 = 0;\n    var i: usize = 0;\n\n    while (i < input.len) {\n        const c = input[i];\n        if (c == ' ') {\n            i += 1;\n            continue;\n        } else if (c >= '0' and c <= '9') {\n            num = num * 10 + (c - '0');\n        } else if (c == '+' or c == '*') {\n            if (op) |op_| {\n                if (op_ == '+') {\n                    result += num;\n                } else {\n                    result *= num;\n                }\n            } else {\n                result = num;\n            }\n            op = c;\n            num = 0;\n        } else if (c == '(') {\n            var depth: usize = 1;\n            i += 1;\n            var start = i;\n            while (depth > 0) {\n                if (input[i] == '(') {\n                    depth += 1;\n                } else if (input[i] == ')') {\n                    depth -= 1;\n                }\n                i += 1;\n            }\n            num = parseExpression(input[start .. i - 1]);\n        } else if (c == ')') {\n            if (op) |op_| {\n                if (op_ == '+') {\n                    result += num;\n                } else {\n                    result *= num;\n                }\n            } else {\n                result = num;\n            }\n            return result;\n        }\n        i += 1;\n    }\n\n    if (op) |op_| {\n        if (op_ == '+') {\n            result += num;\n        } else {\n            result *= num;\n        }\n    } else {\n        result = num;\n    }\n\n    return result;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var buf: [1024]u8 = undefined;\n    var total: i64 = 0;\n\n    while (try in_stream.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        const result = parseExpression(line);\n        total += result;\n    }\n\n    std.debug.print(\"{}\\n\", .{total});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 24: Lobby Layout ---\nYour raft makes it to the tropical island; it turns out that the small crab was an excellent navigator. You make your way to the resort.\n\nAs you enter the lobby, you discover a small problem: the floor is being renovated. You can't even reach the check-in desk until they've finished installing the new tile floor.\n\nThe tiles are all hexagonal; they need to be arranged in a hex grid with a very specific color pattern. Not in the mood to wait, you offer to help figure out the pattern.\n\nThe tiles are all white on one side and black on the other. They start with the white side facing up. The lobby is large enough to fit whatever pattern might need to appear there.\n\nA member of the renovation crew gives you a list of the tiles that need to be flipped over (your puzzle input). Each line in the list identifies a single tile that needs to be flipped by giving a series of steps starting from a reference tile in the very center of the room. (Every line starts from the same reference tile.)\n\nBecause the tiles are hexagonal, every tile has six neighbors: east, southeast, southwest, west, northwest, and northeast. These directions are given in your list, respectively, as e, se, sw, w, nw, and ne. A tile is identified by a series of these directions with no delimiters; for example, esenee identifies the tile you land on if you start at the reference tile and then move one tile east, one tile southeast, one tile northeast, and one tile east.\n\nEach time a tile is identified, it flips from white to black or from black to white. Tiles might be flipped more than once. For example, a line like esew flips a tile immediately adjacent to the reference tile, and a line like nwwswee flips the reference tile itself.\n\nHere is a larger example:\n\nsesenwnenenewseeswwswswwnenewsewsw\nneeenesenwnwwswnenewnwwsewnenwseswesw\nseswneswswsenwwnwse\nnwnwneseeswswnenewneswwnewseswneseene\nswweswneswnenwsewnwneneseenw\neesenwseswswnenwswnwnwsewwnwsene\nsewnenenenesenwsewnenwwwse\nwenwwweseeeweswwwnwwe\nwsweesenenewnwwnwsenewsenwwsesesenwne\nneeswseenwwswnwswswnw\nnenwswwsewswnenenewsenwsenwnesesenew\nenewnwewneswsewnwswenweswnenwsenwsw\nsweneswneswneneenwnewenewwneswswnese\nswwesenesewenwneswnwwneseswwne\nenesenwswwswneneswsenwnewswseenwsese\nwnwnesenesenenwwnenwsewesewsesesew\nnenewswnwewswnenesenwnesewesw\neneswnwswnwsenenwnwnwwseeswneewsenese\nneswnwewnwnwseenwseesewsenwsweewe\nwseweeenwnesenwwwswnew\nIn the above example, 10 tiles are flipped once (to black), and 5 more are flipped twice (to black, then back to white). After all of these instructions have been followed, a total of 10 tiles are black.\n\nGo through the renovation crew's list and determine which tiles they need to flip. After all of the instructions have been followed, how many tiles are left with the black side up?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nconst Coordinate = struct {\n    q: i32,\n    r: i32,\n};\n\nconst directions = [6]Coordinate{\n    .{ .q = 1, .r = 0 },\n    .{ .q = 0, .r = 1 },\n    .{ .q = -1, .r = 1 },\n    .{ .q = -1, .r = 0 },\n    .{ .q = 0, .r = -1 },\n    .{ .q = 1, .r = -1 },\n};\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var blackTiles = std.AutoHashMap(Coordinate, bool).init(std.heap.page_allocator);\n    defer blackTiles.deinit();\n\n    var buf_reader = std.io.bufferedReader(file.reader());\n    var in_stream = buf_reader.reader();\n\n    var buf: [1024]u8 = undefined;\n    while (try in_stream.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        var coord = Coordinate{ .q = 0, .r = 0 };\n        var i: usize = 0;\n        while (i < line.len) {\n            var dir: Coordinate = undefined;\n            if (line[i] == 'e') {\n                dir = directions[0];\n            } else if (line[i] == 'w') {\n                dir = directions[3];\n            } else if (line[i] == 'n' or line[i] == 's') {\n                if (line.len > i + 1) {\n                    if (std.mem.eql(u8, line[i .. i + 2], \"ne\")) {\n                        dir = directions[5];\n                    } else if (std.mem.eql(u8, line[i .. i + 2], \"nw\")) {\n                        dir = directions[4];\n                    } else if (std.mem.eql(u8, line[i .. i + 2], \"se\")) {\n                        dir = directions[1];\n                    } else if (std.mem.eql(u8, line[i .. i + 2], \"sw\")) {\n                        dir = directions[2];\n                    } else {\n                        return error.InvalidInput;\n                    }\n                    i += 1;\n                } else {\n                    return error.InvalidInput;\n                }\n            } else {\n                return error.InvalidInput;\n            }\n            coord.q += dir.q;\n            coord.r += dir.r;\n            i += 1;\n        }\n\n        if (blackTiles.get(coord)) |black| {\n            blackTiles.put(coord, !black) catch unreachable;\n        } else {\n            blackTiles.put(coord, true) catch unreachable;\n        }\n    }\n\n    var count: usize = 0;\n    var it = blackTiles.iterator();\n    while (it.next()) |entry| {\n        if (entry.value_ptr.*) {\n            count += 1;\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{count});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: Dive! ---\nNow, you need to figure out how to pilot this thing.\n\nIt seems like the submarine can take a series of commands like forward 1, down 2, or up 3:\n\nforward X increases the horizontal position by X units.\ndown X increases the depth by X units.\nup X decreases the depth by X units.\nNote that since you're on a submarine, down and up affect your depth, and so they have the opposite result of what you might expect.\n\nThe submarine seems to already have a planned course (your puzzle input). You should probably figure out where it's going. For example:\n\nforward 5\ndown 5\nforward 8\nup 3\ndown 8\nforward 2\nYour horizontal position and depth both start at 0. The steps above would then modify them as follows:\n\nforward 5 adds 5 to your horizontal position, a total of 5.\ndown 5 adds 5 to your depth, resulting in a value of 5.\nforward 8 adds 8 to your horizontal position, a total of 13.\nup 3 decreases your depth by 3, resulting in a value of 2.\ndown 8 adds 8 to your depth, resulting in a value of 10.\nforward 2 adds 2 to your horizontal position, a total of 15.\nAfter following these instructions, you would have a horizontal position of 15 and a depth of 10. (Multiplying these together produces 150.)\n\nCalculate the horizontal position and depth you would have after following the planned course. What do you get if you multiply your final horizontal position by your final depth?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var buffer: [1024]u8 = undefined;\n    var line_reader = reader.reader();\n\n    var horizontal_position: i32 = 0;\n    var depth: i32 = 0;\n\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        var parts = std.mem.split(u8, line, \" \");\n        const direction = parts.next().?;\n        const units = try std.fmt.parseInt(i32, parts.next().?, 10);\n\n        if (std.mem.eql(u8, direction, \"forward\")) {\n            horizontal_position += units;\n        } else if (std.mem.eql(u8, direction, \"down\")) {\n            depth += units;\n        } else if (std.mem.eql(u8, direction, \"up\")) {\n            depth -= units;\n        }\n    }\n\n    const product = horizontal_position * depth;\n    std.debug.print(\"{}\\n\", .{product});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: Dive! ---\nNow, you need to figure out how to pilot this thing.\n\nIt seems like the submarine can take a series of commands like forward 1, down 2, or up 3:\n\nforward X increases the horizontal position by X units.\ndown X increases the depth by X units.\nup X decreases the depth by X units.\nNote that since you're on a submarine, down and up affect your depth, and so they have the opposite result of what you might expect.\n\nThe submarine seems to already have a planned course (your puzzle input). You should probably figure out where it's going. For example:\n\nforward 5\ndown 5\nforward 8\nup 3\ndown 8\nforward 2\nYour horizontal position and depth both start at 0. The steps above would then modify them as follows:\n\nforward 5 adds 5 to your horizontal position, a total of 5.\ndown 5 adds 5 to your depth, resulting in a value of 5.\nforward 8 adds 8 to your horizontal position, a total of 13.\nup 3 decreases your depth by 3, resulting in a value of 2.\ndown 8 adds 8 to your depth, resulting in a value of 10.\nforward 2 adds 2 to your horizontal position, a total of 15.\nAfter following these instructions, you would have a horizontal position of 15 and a depth of 10. (Multiplying these together produces 150.)\n\nCalculate the horizontal position and depth you would have after following the planned course. What do you get if you multiply your final horizontal position by your final depth?\n\nYour puzzle answer was 1451208.\n\n--- Part Two ---\nBased on your calculations, the planned course doesn't seem to make any sense. You find the submarine manual and discover that the process is actually slightly more complicated.\n\nIn addition to horizontal position and depth, you'll also need to track a third value, aim, which also starts at 0. The commands also mean something entirely different than you first thought:\n\ndown X increases your aim by X units.\nup X decreases your aim by X units.\nforward X does two things:\nIt increases your horizontal position by X units.\nIt increases your depth by your aim multiplied by X.\nAgain note that since you're on a submarine, down and up do the opposite of what you might expect: \"down\" means aiming in the positive direction.\n\nNow, the above example does something different:\n\nforward 5 adds 5 to your horizontal position, a total of 5. Because your aim is 0, your depth does not change.\ndown 5 adds 5 to your aim, resulting in a value of 5.\nforward 8 adds 8 to your horizontal position, a total of 13. Because your aim is 5, your depth increases by 8*5=40.\nup 3 decreases your aim by 3, resulting in a value of 2.\ndown 8 adds 8 to your aim, resulting in a value of 10.\nforward 2 adds 2 to your horizontal position, a total of 15. Because your aim is 10, your depth increases by 2*10=20 to a total of 60.\nAfter following these new instructions, you would have a horizontal position of 15 and a depth of 60. (Multiplying these produces 900.)\n\nUsing this new interpretation of the commands, calculate the horizontal position and depth you would have after following the planned course. What do you get if you multiply your final horizontal position by your final depth?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_reader = reader.reader();\n\n    var horizontal_position: i32 = 0;\n    var depth: i32 = 0;\n    var aim: i32 = 0;\n\n    var buffer: [1024]u8 = undefined;\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        var parts = std.mem.split(u8, line, \" \");\n        const direction = parts.next().?;\n        const units = try std.fmt.parseInt(i32, parts.next().?, 10);\n\n        if (std.mem.eql(u8, direction, \"forward\")) {\n            horizontal_position += units;\n            depth += aim * units;\n        } else if (std.mem.eql(u8, direction, \"down\")) {\n            aim += units;\n        } else if (std.mem.eql(u8, direction, \"up\")) {\n            aim -= units;\n        }\n    }\n\n    const product = horizontal_position * depth;\n    std.debug.print(\"{d}\\n\", .{product});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 5: Hydrothermal Venture ---\nYou come across a field of hydrothermal vents on the ocean floor! These vents constantly produce large, opaque clouds, so it would be best to avoid them if possible.\n\nThey tend to form in lines; the submarine helpfully produces a list of nearby lines of vents (your puzzle input) for you to review. For example:\n\n0,9 -> 5,9\n8,0 -> 0,8\n9,4 -> 3,4\n2,2 -> 2,1\n7,0 -> 7,4\n6,4 -> 2,0\n0,9 -> 2,9\n3,4 -> 1,4\n0,0 -> 8,8\n5,5 -> 8,2\nEach line of vents is given as a line segment in the format x1,y1 -> x2,y2 where x1,y1 are the coordinates of one end the line segment and x2,y2 are the coordinates of the other end. These line segments include the points at both ends. In other words:\n\nAn entry like 1,1 -> 1,3 covers points 1,1, 1,2, and 1,3.\nAn entry like 9,7 -> 7,7 covers points 9,7, 8,7, and 7,7.\nFor now, only consider horizontal and vertical lines: lines where either x1 = x2 or y1 = y2.\n\nSo, the horizontal and vertical lines from the above list would produce the following diagram:\n\n.......1..\n..1....1..\n..1....1..\n.......1..\n.112111211\n..........\n..........\n..........\n..........\n222111....\nIn this diagram, the top left corner is 0,0 and the bottom right corner is 9,9. Each position is shown as the number of lines which cover that point or . if no line covers that point. The top-left pair of 1s, for example, comes from 2,2 -> 2,1; the very bottom row is formed by the overlapping lines 0,9 -> 5,9 and 0,9 -> 2,9.\n\nTo avoid the most dangerous areas, you need to determine the number of points where at least two lines overlap. In the above example, this is anywhere in the diagram with a 2 or larger - a total of 5 points.\n\nConsider only horizontal and vertical lines. At how many points do at least two lines overlap?\n\nYour puzzle answer was 7380.\n\n--- Part Two ---\nUnfortunately, considering only horizontal and vertical lines doesn't give you the full picture; you need to also consider diagonal lines.\n\nBecause of the limits of the hydrothermal vent mapping system, the lines in your list will only ever be horizontal, vertical, or a diagonal line at exactly 45 degrees. In other words:\n\nAn entry like 1,1 -> 3,3 covers points 1,1, 2,2, and 3,3.\nAn entry like 9,7 -> 7,9 covers points 9,7, 8,8, and 7,9.\nConsidering all lines from the above example would now produce the following diagram:\n\n1.1....11.\n.111...2..\n..2.1.111.\n...1.2.2..\n.112313211\n...1.2....\n..1...1...\n.1.....1..\n1.......1.\n222111....\nYou still need to determine the number of points where at least two lines overlap. In the above example, this is still anywhere in the diagram with a 2 or larger - now a total of 12 points.\n\nConsider all of the lines. At how many points do at least two lines overlap?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn abs(x: i32) i32 {\n    if (x < 0) return -x else return x;\n}\n\nfn sign(x: i32) i32 {\n    if (x > 0) return 1 else if (x < 0) return -1 else return 0;\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_buffer: [1024]u8 = undefined;\n    var line_reader = reader.reader();\n\n    var lines = std.ArrayList([4]i32).init(std.heap.page_allocator);\n    defer lines.deinit();\n\n    while (try line_reader.readUntilDelimiterOrEof(&line_buffer, '\\n')) |line| {\n        var parts = std.mem.split(u8, line, \" -> \");\n        var start = std.mem.split(u8, parts.next().?, \",\");\n        var end = std.mem.split(u8, parts.next().?, \",\");\n\n        const x1 = try std.fmt.parseInt(i32, start.next().?, 10);\n        const y1 = try std.fmt.parseInt(i32, start.next().?, 10);\n        const x2 = try std.fmt.parseInt(i32, end.next().?, 10);\n        const y2 = try std.fmt.parseInt(i32, end.next().?, 10);\n\n        try lines.append([4]i32{ x1, y1, x2, y2 });\n    }\n\n    var overlaps = std.AutoHashMap([2]i32, i32).init(std.heap.page_allocator);\n    defer overlaps.deinit();\n\n    for (lines.items) |line| {\n        const x1 = line[0];\n        const y1 = line[1];\n        const x2 = line[2];\n        const y2 = line[3];\n\n        const xStep = sign(x2 - x1);\n        const yStep = sign(y2 - y1);\n        var steps = abs(x2 - x1) + 1;\n        if (abs(y2 - y1) > abs(x2 - x1)) {\n            steps = abs(y2 - y1) + 1;\n        }\n\n        var i: i32 = 0;\n        while (i < steps) : (i += 1) {\n            const point = [2]i32{ x1 + i * xStep, y1 + i * yStep };\n            const count = overlaps.get(point) orelse 0;\n            try overlaps.put(point, count + 1);\n        }\n    }\n\n    var count: i32 = 0;\n    var it = overlaps.iterator();\n    while (it.next()) |entry| {\n        if (entry.value_ptr.* > 1) {\n            count += 1;\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{count});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 10: Syntax Scoring ---\nYou ask the submarine to determine the best route out of the deep-sea cave, but it only replies:\n\nSyntax error in navigation subsystem on line: all of them\nAll of them?! The damage is worse than you thought. You bring up a copy of the navigation subsystem (your puzzle input).\n\nThe navigation subsystem syntax is made of several lines containing chunks. There are one or more chunks on each line, and chunks contain zero or more other chunks. Adjacent chunks are not separated by any delimiter; if one chunk stops, the next chunk (if any) can immediately start. Every chunk must open and close with one of four legal pairs of matching characters:\n\nIf a chunk opens with (, it must close with ).\nIf a chunk opens with [, it must close with ].\nIf a chunk opens with {, it must close with }.\nIf a chunk opens with <, it must close with >.\nSo, () is a legal chunk that contains no other chunks, as is []. More complex but valid chunks include ([]), {()()()}, <([{}])>, [<>({}){}[([])<>]], and even (((((((((()))))))))).\n\nSome lines are incomplete, but others are corrupted. Find and discard the corrupted lines first.\n\nA corrupted line is one where a chunk closes with the wrong character - that is, where the characters it opens and closes with do not form one of the four legal pairs listed above.\n\nExamples of corrupted chunks include (], {()()()>, (((()))}, and <([]){()}[{}]). Such a chunk can appear anywhere within a line, and its presence causes the whole line to be considered corrupted.\n\nFor example, consider the following navigation subsystem:\n\n[({(<(())[]>[[{[]{<()<>>\n[(()[<>])]({[<{<<[]>>(\n{([(<{}[<>[]}>{[]{[(<()>\n(((({<>}<{<{<>}{[]{[]{}\n[[<[([]))<([[{}[[()]]]\n[{[{({}]{}}([{[{{{}}([]\n{<[[]]>}<{[{[{[]{()[[[]\n[<(<(<(<{}))><([]([]()\n<{([([[(<>()){}]>(<<{{\n<{([{{}}[<[[[<>{}]]]>[]]\nSome of the lines aren't corrupted, just incomplete; you can ignore these lines for now. The remaining five lines are corrupted:\n\n{([(<{}[<>[]}>{[]{[(<()> - Expected ], but found } instead.\n[[<[([]))<([[{}[[()]]] - Expected ], but found ) instead.\n[{[{({}]{}}([{[{{{}}([] - Expected ), but found ] instead.\n[<(<(<(<{}))><([]([]() - Expected >, but found ) instead.\n<{([([[(<>()){}]>(<<{{ - Expected ], but found > instead.\nStop at the first incorrect closing character on each corrupted line.\n\nDid you know that syntax checkers actually have contests to see who can get the high score for syntax errors in a file? It's true! To calculate the syntax error score for a line, take the first illegal character on the line and look it up in the following table:\n\n): 3 points.\n]: 57 points.\n}: 1197 points.\n>: 25137 points.\nIn the above example, an illegal ) was found twice (2*3 = 6 points), an illegal ] was found once (57 points), an illegal } was found once (1197 points), and an illegal > was found once (25137 points). So, the total syntax error score for this file is 6+57+1197+25137 = 26397 points!\n\nFind the first illegal character in each corrupted line of the navigation subsystem. What is the total syntax error score for those errors?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn checkLine(line: []const u8) ?u64 {\n    const pairings = [_]u8{ '(', ')', '[', ']', '{', '}', '<', '>' };\n    const scores = [_]u64{ 3, 3, 57, 57, 1197, 1197, 25137, 25137 };\n    var stack: [128]u8 = undefined;\n    var top: usize = 0;\n\n    for (line) |char| {\n        const index = std.mem.indexOfScalar(u8, &pairings, char).?;\n        switch (index) {\n            0, 2, 4, 6 => { // opening characters\n                stack[top] = char;\n                top += 1;\n            },\n            1, 3, 5, 7 => { // closing characters\n                if (top == 0 or stack[top - 1] != pairings[index - 1]) {\n                    return scores[index]; // corrupted line\n                }\n                top -= 1;\n            },\n            else => unreachable,\n        }\n    }\n\n    return null; // line is not corrupted\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var buf_reader = reader.reader();\n    var buf: [1024]u8 = undefined;\n\n    var total_score: u64 = 0;\n    while (try buf_reader.readUntilDelimiterOrEof(&buf, '\\n')) |line| {\n        if (checkLine(line)) |score| {\n            total_score += score;\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{total_score});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 21: Dirac Dice ---\nThere's not much to do as you slowly descend to the bottom of the ocean. The submarine computer challenges you to a nice game of Dirac Dice.\n\nThis game consists of a single die, two pawns, and a game board with a circular track containing ten spaces marked 1 through 10 clockwise. Each player's starting space is chosen randomly (your puzzle input). Player 1 goes first.\n\nPlayers take turns moving. On each player's turn, the player rolls the die three times and adds up the results. Then, the player moves their pawn that many times forward around the track (that is, moving clockwise on spaces in order of increasing value, wrapping back around to 1 after 10). So, if a player is on space 7 and they roll 2, 2, and 1, they would move forward 5 times, to spaces 8, 9, 10, 1, and finally stopping on 2.\n\nAfter each player moves, they increase their score by the value of the space their pawn stopped on. Players' scores start at 0. So, if the first player starts on space 7 and rolls a total of 5, they would stop on space 2 and add 2 to their score (for a total score of 2). The game immediately ends as a win for any player whose score reaches at least 1000.\n\nSince the first game is a practice game, the submarine opens a compartment labeled deterministic dice and a 100-sided die falls out. This die always rolls 1 first, then 2, then 3, and so on up to 100, after which it starts over at 1 again. Play using this die.\n\nFor example, given these starting positions:\n\nPlayer 1 starting position: 4\nPlayer 2 starting position: 8\nThis is how the game would go:\n\nPlayer 1 rolls 1+2+3 and moves to space 10 for a total score of 10.\nPlayer 2 rolls 4+5+6 and moves to space 3 for a total score of 3.\nPlayer 1 rolls 7+8+9 and moves to space 4 for a total score of 14.\nPlayer 2 rolls 10+11+12 and moves to space 6 for a total score of 9.\nPlayer 1 rolls 13+14+15 and moves to space 6 for a total score of 20.\nPlayer 2 rolls 16+17+18 and moves to space 7 for a total score of 16.\nPlayer 1 rolls 19+20+21 and moves to space 6 for a total score of 26.\nPlayer 2 rolls 22+23+24 and moves to space 6 for a total score of 22.\n...after many turns...\n\nPlayer 2 rolls 82+83+84 and moves to space 6 for a total score of 742.\nPlayer 1 rolls 85+86+87 and moves to space 4 for a total score of 990.\nPlayer 2 rolls 88+89+90 and moves to space 3 for a total score of 745.\nPlayer 1 rolls 91+92+93 and moves to space 10 for a final score, 1000.\nSince player 1 has at least 1000 points, player 1 wins and the game ends. At this point, the losing player had 745 points and the die had been rolled a total of 993 times; 745 * 993 = 739785.\n\nPlay a practice game using the deterministic 100-sided die. The moment either player wins, what do you get if you multiply the score of the losing player by the number of times the die was rolled during the game?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    const file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    const contents = try file.readToEndAlloc(allocator, std.math.maxInt(usize));\n    defer allocator.free(contents);\n\n    var lines = std.mem.split(u8, contents, \"\\n\");\n\n    const player1StartStr = lines.next().?;\n    const player1StartPos = try std.fmt.parseInt(i32, player1StartStr[28..], 10);\n    const player2StartStr = lines.next().?;\n    const player2StartPos = try std.fmt.parseInt(i32, player2StartStr[28..], 10);\n\n    var player1Pos: i32 = player1StartPos;\n    var player2Pos: i32 = player2StartPos;\n\n    var player1Score: i32 = 0;\n    var player2Score: i32 = 0;\n\n    var dieRoll: i32 = 1;\n    var rollCount: i32 = 0;\n\n    while (true) {\n        // Player 1\n        const rolls = @mod(dieRoll, 100) + @mod(dieRoll + 1, 100) + @mod(dieRoll + 2, 100);\n        rollCount += 3;\n        dieRoll += 3;\n\n        player1Pos = @mod(player1Pos + rolls - 1, 10) + 1;\n        player1Score += player1Pos;\n\n        if (player1Score >= 1000) {\n            std.debug.print(\"Result: {}\\n\", .{player2Score * rollCount});\n            return;\n        }\n\n        // Player 2\n        const rolls2 = @mod(dieRoll, 100) + @mod(dieRoll + 1, 100) + @mod(dieRoll + 2, 100);\n        rollCount += 3;\n        dieRoll += 3;\n\n        player2Pos = @mod(player2Pos + rolls2 - 1, 10) + 1;\n        player2Score += player2Pos;\n\n        if (player2Score >= 1000) {\n            std.debug.print(\"{}\\n\", .{player1Score * rollCount});\n            return;\n        }\n    }\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 1: Calorie Counting ---\nSanta's reindeer typically eat regular reindeer food, but they need a lot of magical energy to deliver presents on Christmas. For that, their favorite snack is a special type of star fruit that only grows deep in the jungle. The Elves have brought you on their annual expedition to the grove where the fruit grows.\n\nTo supply enough magical energy, the expedition needs to retrieve a minimum of fifty stars by December 25th. Although the Elves assure you that the grove has plenty of fruit, you decide to grab any fruit you see along the way, just in case.\n\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nThe jungle must be too overgrown and difficult to navigate in vehicles or access from the air; the Elves' expedition traditionally goes on foot. As your boats approach land, the Elves begin taking inventory of their supplies. One important consideration is food - in particular, the number of Calories each Elf is carrying (your puzzle input).\n\nThe Elves take turns writing down the number of Calories contained by the various meals, snacks, rations, etc. that they've brought with them, one item per line. Each Elf separates their own inventory from the previous Elf's inventory (if any) by a blank line.\n\nFor example, suppose the Elves finish writing their items' Calories and end up with the following list:\n\n1000\n2000\n3000\n\n4000\n\n5000\n6000\n\n7000\n8000\n9000\n\n10000\nThis list represents the Calories of the food carried by five Elves:\n\nThe first Elf is carrying food with 1000, 2000, and 3000 Calories, a total of 6000 Calories.\nThe second Elf is carrying one food item with 4000 Calories.\nThe third Elf is carrying food with 5000 and 6000 Calories, a total of 11000 Calories.\nThe fourth Elf is carrying food with 7000, 8000, and 9000 Calories, a total of 24000 Calories.\nThe fifth Elf is carrying one food item with 10000 Calories.\nIn case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they'd like to know how many Calories are being carried by the Elf carrying the most Calories. In the example above, this is 24000 (carried by the fourth Elf).\n\nFind the Elf carrying the most Calories. How many total Calories is that Elf carrying?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = file.reader();\n    var line_buffer: [1024]u8 = undefined;\n    var current_calories: u32 = 0;\n    var max_calories: u32 = 0;\n\n    while (try reader.readUntilDelimiterOrEof(&line_buffer, '\\n')) |line| {\n        if (line.len == 0) {\n            if (current_calories > max_calories) {\n                max_calories = current_calories;\n            }\n            current_calories = 0;\n        } else {\n            current_calories += try std.fmt.parseInt(u32, line, 10);\n        }\n    }\n\n    if (current_calories > max_calories) {\n        max_calories = current_calories;\n    }\n\n    std.debug.print(\"The Elf carrying the most Calories is carrying {} Calories.\\n\", .{max_calories});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 2: Rock Paper Scissors ---\nThe Elves begin to set up camp on the beach. To decide whose tent gets to be closest to the snack storage, a giant Rock Paper Scissors tournament is already in progress.\n\nRock Paper Scissors is a game between two players. Each game contains many rounds; in each round, the players each simultaneously choose one of Rock, Paper, or Scissors using a hand shape. Then, a winner for that round is selected: Rock defeats Scissors, Scissors defeats Paper, and Paper defeats Rock. If both players choose the same shape, the round instead ends in a draw.\n\nAppreciative of your help yesterday, one Elf gives you an encrypted strategy guide (your puzzle input) that they say will be sure to help you win. \"The first column is what your opponent is going to play: A for Rock, B for Paper, and C for Scissors. The second column--\" Suddenly, the Elf is called away to help with someone's tent.\n\nThe second column, you reason, must be what you should play in response: X for Rock, Y for Paper, and Z for Scissors. Winning every time would be suspicious, so the responses must have been carefully chosen.\n\nThe winner of the whole tournament is the player with the highest score. Your total score is the sum of your scores for each round. The score for a single round is the score for the shape you selected (1 for Rock, 2 for Paper, and 3 for Scissors) plus the score for the outcome of the round (0 if you lost, 3 if the round was a draw, and 6 if you won).\n\nSince you can't be sure if the Elf is trying to help you or trick you, you should calculate the score you would get if you were to follow the strategy guide.\n\nFor example, suppose you were given the following strategy guide:\n\nA Y\nB X\nC Z\nThis strategy guide predicts and recommends the following:\n\nIn the first round, your opponent will choose Rock (A), and you should choose Paper (Y). This ends in a win for you with a score of 8 (2 because you chose Paper + 6 because you won).\nIn the second round, your opponent will choose Paper (B), and you should choose Rock (X). This ends in a loss for you with a score of 1 (1 + 0).\nThe third round is a draw with both players choosing Scissors, giving you a score of 3 + 3 = 6.\nIn this example, if you were to follow the strategy guide, you would get a total score of 15 (8 + 1 + 6).\n\nWhat would your total score be if everything goes exactly according to your strategy guide?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var line_reader = reader.reader();\n\n    var total_score: i32 = 0;\n\n    var buffer: [1024]u8 = undefined;\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        const opponent = line[0];\n        const your_move = line[2];\n\n        var score: i32 = 0;\n        if (your_move == 'X') {\n            score = 1;\n        } else if (your_move == 'Y') {\n            score = 2;\n        } else if (your_move == 'Z') {\n            score = 3;\n        }\n\n        if ((opponent == 'A' and your_move == 'Y') or (opponent == 'B' and your_move == 'Z') or (opponent == 'C' and your_move == 'X')) {\n            score += 6;\n        } else if ((opponent == 'A' and your_move == 'X') or (opponent == 'B' and your_move == 'Y') or (opponent == 'C' and your_move == 'Z')) {\n            score += 3;\n        }\n\n        total_score += score;\n    }\n\n    std.debug.print(\"{}\\n\", .{total_score});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 4: Camp Cleanup ---\nSpace needs to be cleared before the last supplies can be unloaded from the ships, and so several Elves have been assigned the job of cleaning up sections of the camp. Every section has a unique ID number, and each Elf is assigned a range of section IDs.\n\nHowever, as some of the Elves compare their section assignments with each other, they've noticed that many of the assignments overlap. To try to quickly find overlaps and reduce duplicated effort, the Elves pair up and make a big list of the section assignments for each pair (your puzzle input).\n\nFor example, consider the following list of section assignment pairs:\n\n2-4,6-8\n2-3,4-5\n5-7,7-9\n2-8,3-7\n6-6,4-6\n2-6,4-8\nFor the first few pairs, this list means:\n\nWithin the first pair of Elves, the first Elf was assigned sections 2-4 (sections 2, 3, and 4), while the second Elf was assigned sections 6-8 (sections 6, 7, 8).\nThe Elves in the second pair were each assigned two sections.\nThe Elves in the third pair were each assigned three sections: one got sections 5, 6, and 7, while the other also got 7, plus 8 and 9.\nThis example list uses single-digit section IDs to make it easier to draw; your actual list might contain larger numbers. Visually, these pairs of section assignments look like this:\n\n.234.....  2-4\n.....678.  6-8\n\n.23......  2-3\n...45....  4-5\n\n....567..  5-7\n......789  7-9\n\n.2345678.  2-8\n..34567..  3-7\n\n.....6...  6-6\n...456...  4-6\n\n.23456...  2-6\n...45678.  4-8\nSome of the pairs have noticed that one of their assignments fully contains the other. For example, 2-8 fully contains 3-7, and 6-6 is fully contained by 4-6. In pairs where one assignment fully contains the other, one Elf in the pair would be exclusively cleaning sections their partner will already be cleaning, so these seem like the most in need of reconsideration. In this example, there are 2 such pairs.\n\nIn how many assignment pairs does one range fully contain the other?\n\nYour puzzle answer was 526.\n\n--- Part Two ---\nIt seems like there is still quite a bit of duplicate work planned. Instead, the Elves would like to know the number of pairs that overlap at all.\n\nIn the above example, the first two pairs (2-4,6-8 and 2-3,4-5) don't overlap, while the remaining four pairs (5-7,7-9, 2-8,3-7, 6-6,4-6, and 2-6,4-8) do overlap:\n\n5-7,7-9 overlaps in a single section, 7.\n2-8,3-7 overlaps all of the sections 3 through 7.\n6-6,4-6 overlaps in a single section, 6.\n2-6,4-8 overlaps in sections 4, 5, and 6.\nSo, in this example, the number of overlapping assignment pairs is 4.\n\nIn how many assignment pairs do the ranges overlap?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nfn parseRange(s: []const u8) [2]i32 {\n    var it = std.mem.tokenize(u8, s, \"-\");\n    const start = std.fmt.parseInt(i32, it.next().?, 10) catch unreachable;\n    const end = std.fmt.parseInt(i32, it.next().?, 10) catch unreachable;\n    return [2]i32{ start, end };\n}\n\npub fn main() !void {\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = std.io.bufferedReader(file.reader());\n    var buffer: [1024]u8 = undefined;\n    var line_reader = reader.reader();\n\n    var count: usize = 0;\n    while (try line_reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        var it = std.mem.tokenize(u8, line, \",\");\n        const left = parseRange(it.next().?);\n        const right = parseRange(it.next().?);\n\n        if (left[0] <= right[1] and left[1] >= right[0]) {\n            count += 1;\n        }\n    }\n\n    std.debug.print(\"{}\\n\", .{count});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 10: Cathode-Ray Tube ---\nYou avoid the ropes, plunge into the river, and swim to shore.\n\nThe Elves yell something about meeting back up with them upriver, but the river is too loud to tell exactly what they're saying. They finish crossing the bridge and disappear from view.\n\nSituations like this must be why the Elves prioritized getting the communication system on your handheld device working. You pull it out of your pack, but the amount of water slowly draining from a big crack in its screen tells you it probably won't be of much immediate use.\n\nUnless, that is, you can design a replacement for the device's video system! It seems to be some kind of cathode-ray tube screen and simple CPU that are both driven by a precise clock circuit. The clock circuit ticks at a constant rate; each tick is called a cycle.\n\nStart by figuring out the signal being sent by the CPU. The CPU has a single register, X, which starts with the value 1. It supports only two instructions:\n\naddx V takes two cycles to complete. After two cycles, the X register is increased by the value V. (V can be negative.)\nnoop takes one cycle to complete. It has no other effect.\nThe CPU uses these instructions in a program (your puzzle input) to, somehow, tell the screen what to draw.\n\nConsider the following small program:\n\nnoop\naddx 3\naddx -5\nExecution of this program proceeds as follows:\n\nAt the start of the first cycle, the noop instruction begins execution. During the first cycle, X is 1. After the first cycle, the noop instruction finishes execution, doing nothing.\nAt the start of the second cycle, the addx 3 instruction begins execution. During the second cycle, X is still 1.\nDuring the third cycle, X is still 1. After the third cycle, the addx 3 instruction finishes execution, setting X to 4.\nAt the start of the fourth cycle, the addx -5 instruction begins execution. During the fourth cycle, X is still 4.\nDuring the fifth cycle, X is still 4. After the fifth cycle, the addx -5 instruction finishes execution, setting X to -1.\nMaybe you can learn something by looking at the value of the X register throughout execution. For now, consider the signal strength (the cycle number multiplied by the value of the X register) during the 20th cycle and every 40 cycles after that (that is, during the 20th, 60th, 100th, 140th, 180th, and 220th cycles).\n\nFor example, consider this larger program:\n\naddx 15\naddx -11\naddx 6\naddx -3\naddx 5\naddx -1\naddx -8\naddx 13\naddx 4\nnoop\naddx -1\naddx 5\naddx -1\naddx 5\naddx -1\naddx 5\naddx -1\naddx 5\naddx -1\naddx -35\naddx 1\naddx 24\naddx -19\naddx 1\naddx 16\naddx -11\nnoop\nnoop\naddx 21\naddx -15\nnoop\nnoop\naddx -3\naddx 9\naddx 1\naddx -3\naddx 8\naddx 1\naddx 5\nnoop\nnoop\nnoop\nnoop\nnoop\naddx -36\nnoop\naddx 1\naddx 7\nnoop\nnoop\nnoop\naddx 2\naddx 6\nnoop\nnoop\nnoop\nnoop\nnoop\naddx 1\nnoop\nnoop\naddx 7\naddx 1\nnoop\naddx -13\naddx 13\naddx 7\nnoop\naddx 1\naddx -33\nnoop\nnoop\nnoop\naddx 2\nnoop\nnoop\nnoop\naddx 8\nnoop\naddx -1\naddx 2\naddx 1\nnoop\naddx 17\naddx -9\naddx 1\naddx 1\naddx -3\naddx 11\nnoop\nnoop\naddx 1\nnoop\naddx 1\nnoop\nnoop\naddx -13\naddx -19\naddx 1\naddx 3\naddx 26\naddx -30\naddx 12\naddx -1\naddx 3\naddx 1\nnoop\nnoop\nnoop\naddx -9\naddx 18\naddx 1\naddx 2\nnoop\nnoop\naddx 9\nnoop\nnoop\nnoop\naddx -1\naddx 2\naddx -37\naddx 1\naddx 3\nnoop\naddx 15\naddx -21\naddx 22\naddx -6\naddx 1\nnoop\naddx 2\naddx 1\nnoop\naddx -10\nnoop\nnoop\naddx 20\naddx 1\naddx 2\naddx 2\naddx -6\naddx -11\nnoop\nnoop\nnoop\nThe interesting signal strengths can be determined as follows:\n\nDuring the 20th cycle, register X has the value 21, so the signal strength is 20 * 21 = 420. (The 20th cycle occurs in the middle of the second addx -1, so the value of register X is the starting value, 1, plus all of the other addx values up to that point: 1 + 15 - 11 + 6 - 3 + 5 - 1 - 8 + 13 + 4 = 21.)\nDuring the 60th cycle, register X has the value 19, so the signal strength is 60 * 19 = 1140.\nDuring the 100th cycle, register X has the value 18, so the signal strength is 100 * 18 = 1800.\nDuring the 140th cycle, register X has the value 21, so the signal strength is 140 * 21 = 2940.\nDuring the 180th cycle, register X has the value 16, so the signal strength is 180 * 16 = 2880.\nDuring the 220th cycle, register X has the value 18, so the signal strength is 220 * 18 = 3960.\nThe sum of these signal strengths is 13140.\n\nFind the signal strength during the 20th, 60th, 100th, 140th, 180th, and 220th cycles. What is the sum of these six signal strengths?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = file.reader();\n    var buffer: [1024]u8 = undefined;\n    var x: i32 = 1;\n    var cycle: i32 = 0;\n    var sum: i32 = 0;\n\n    while (try reader.readUntilDelimiterOrEof(&buffer, '\\n')) |line| {\n        if (std.mem.eql(u8, line, \"noop\")) {\n            cycle += 1;\n            if (cycle == 20 or @rem(cycle - 20, 40) == 0) {\n                sum += cycle * x;\n            }\n        } else {\n            const value = try std.fmt.parseInt(i32, line[5..], 10);\n            cycle += 1;\n            if (cycle == 20 or @rem(cycle - 20, 40) == 0) {\n                sum += cycle * x;\n            }\n            cycle += 1;\n            if (cycle == 20 or @rem(cycle - 20, 40) == 0) {\n                sum += cycle * x;\n            }\n            x += value;\n        }\n    }\n\n    std.debug.print(\"Sum of signal strengths: {}\\n\", .{sum});\n}\n```\n","role":"assistant"}]}
{"messages":[{"content":"You are a highly experienced programmer with a PhD in computer science participating in a coding challenge.\nWrite clean, efficient code without unnecessary comments, demonstrating your advanced skills by solving problems practically and concisely.\nAim to produce optimal and concise solutions, leveraging your decade of industry experience.","role":"system"},{"content":"Write an zig program that reads input from a file called input.txt and prints the output to standard output.\nFocus on writing clean, efficient code that demonstrates your programming skills by concisely solving the challenge.\n\nCoding challenge:\n--- Day 18: Boiling Boulders ---\nYou and the elephants finally reach fresh air. You've emerged near the base of a large volcano that seems to be actively erupting! Fortunately, the lava seems to be flowing away from you and toward the ocean.\n\nBits of lava are still being ejected toward you, so you're sheltering in the cavern exit a little longer. Outside the cave, you can see the lava landing in a pond and hear it loudly hissing as it solidifies.\n\nDepending on the specific compounds in the lava and speed at which it cools, it might be forming obsidian! The cooling rate should be based on the surface area of the lava droplets, so you take a quick scan of a droplet as it flies past you (your puzzle input).\n\nBecause of how quickly the lava is moving, the scan isn't very good; its resolution is quite low and, as a result, it approximates the shape of the lava droplet with 1x1x1 cubes on a 3D grid, each given as its x,y,z position.\n\nTo approximate the surface area, count the number of sides of each cube that are not immediately connected to another cube. So, if your scan were only two adjacent cubes like 1,1,1 and 2,1,1, each cube would have a single side covered and five sides exposed, a total surface area of 10 sides.\n\nHere's a larger example:\n\n2,2,2\n1,2,2\n3,2,2\n2,1,2\n2,3,2\n2,2,1\n2,2,3\n2,2,4\n2,2,6\n1,2,5\n3,2,5\n2,1,5\n2,3,5\nIn the above example, after counting up all the sides that aren't connected to another cube, the total surface area is 64.\n\nWhat is the surface area of your scanned lava droplet?\n\nYour puzzle answer was 4314.\n\n--- Part Two ---\nSomething seems off about your calculation. The cooling rate depends on exterior surface area, but your calculation also included the surface area of air pockets trapped in the lava droplet.\n\nInstead, consider only cube sides that could be reached by the water and steam as the lava droplet tumbles into the pond. The steam will expand to reach as much as possible, completely displacing any air on the outside of the lava droplet but never expanding diagonally.\n\nIn the larger example above, exactly one cube of air is trapped within the lava droplet (at 2,2,5), so the exterior surface area of the lava droplet is 58.\n\nWhat is the exterior surface area of your scanned lava droplet?\n","role":"user"},{"content":"Here is a solution of the challenge:\n```zig\nconst std = @import(\"std\");\n\nconst Pt3 = struct {\n    x: i32,\n    y: i32,\n    z: i32,\n};\n\nfn addPt3(p1: Pt3, p2: Pt3) Pt3 {\n    return Pt3{ .x = p1.x + p2.x, .y = p1.y + p2.y, .z = p1.z + p2.z };\n}\n\nfn minInt(a: i32, b: i32) i32 {\n    return if (a < b) a else b;\n}\n\nfn maxInt(a: i32, b: i32) i32 {\n    return if (a > b) a else b;\n}\n\npub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    var cubes = std.AutoHashMap(Pt3, void).init(allocator);\n    defer cubes.deinit();\n\n    const neighbors = [6]Pt3{\n        Pt3{ .x = -1, .y = 0, .z = 0 },\n        Pt3{ .x = 1, .y = 0, .z = 0 },\n        Pt3{ .x = 0, .y = -1, .z = 0 },\n        Pt3{ .x = 0, .y = 1, .z = 0 },\n        Pt3{ .x = 0, .y = 0, .z = -1 },\n        Pt3{ .x = 0, .y = 0, .z = 1 },\n    };\n\n    var min_pt = Pt3{ .x = std.math.maxInt(i32), .y = std.math.maxInt(i32), .z = std.math.maxInt(i32) };\n    var max_pt = Pt3{ .x = std.math.minInt(i32), .y = std.math.minInt(i32), .z = std.math.minInt(i32) };\n\n    var file = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer file.close();\n\n    var reader = file.reader();\n    var buf: [1024]u8 = undefined;\n    var line_reader = std.io.bufferedReader(reader);\n    var in = line_reader.reader();\n\n    while (try in.readUntilDelimiterOrEof(buf[0..], '\\n')) |line| {\n        if (line.len == 0) continue;\n\n        var parts = std.mem.split(u8, line, \",\");\n        const x = try std.fmt.parseInt(i32, parts.next().?, 10);\n        const y = try std.fmt.parseInt(i32, parts.next().?, 10);\n        const z = try std.fmt.parseInt(i32, parts.next().?, 10);\n\n        const cube = Pt3{ .x = x, .y = y, .z = z };\n        try cubes.put(cube, {});\n\n        min_pt = Pt3{\n            .x = minInt(min_pt.x, cube.x),\n            .y = minInt(min_pt.y, cube.y),\n            .z = minInt(min_pt.z, cube.z),\n        };\n        max_pt = Pt3{\n            .x = maxInt(max_pt.x, cube.x),\n            .y = maxInt(max_pt.y, cube.y),\n            .z = maxInt(max_pt.z, cube.z),\n        };\n    }\n\n    min_pt = addPt3(min_pt, Pt3{ .x = -1, .y = -1, .z = -1 });\n    max_pt = addPt3(max_pt, Pt3{ .x = 1, .y = 1, .z = 1 });\n\n    var faces: usize = 0;\n    var queue = std.ArrayList(Pt3).init(allocator);\n    defer queue.deinit();\n\n    var seen = std.AutoHashMap(Pt3, void).init(allocator);\n    defer seen.deinit();\n\n    try seen.put(min_pt, {});\n    try queue.append(min_pt);\n\n    while (queue.items.len > 0) {\n        const curr = queue.pop();\n\n        for (neighbors) |delta| {\n            const next = addPt3(curr, delta);\n            if (next.x < min_pt.x or\n                next.y < min_pt.y or\n                next.z < min_pt.z or\n                next.x > max_pt.x or\n                next.y > max_pt.y or\n                next.z > max_pt.z)\n            {\n                continue;\n            }\n\n            if (cubes.contains(next)) {\n                faces += 1;\n            } else if (!seen.contains(next)) {\n                try seen.put(next, {});\n                try queue.append(next);\n            }\n        }\n    }\n\n    std.debug.print(\"{d}\\n\", .{faces});\n}\n```\n","role":"assistant"}]}
