
(define (solve input-file part2?)
  (define (parse-input lines)
    (let ((items (make-vector 0)))
      (for-each (lambda (line)
                 (let ((parts (string-split line " ")))
                   (let loop ((parts parts) (floor (vector-length items)))
                     (cond ((null? parts) #t)
                           ((string=? (car parts) "generator")
                            (vector-push! items (list (string->symbol (string-append (cadr parts) "g")) floor))
                            (loop (cddr parts) floor))
                           ((string=? (car parts) "microchip")
                            (vector-push! items (list (string->symbol (string-append (cadr parts) "m")) floor))
                            (loop (cddr parts) floor))
                           (else (loop (cdr parts) floor))))))
               lines)
      items))

  (define (valid-state? state)
    (let ((floors (make-vector 4 (list))))
      (for-each (lambda (item)
                 (vector-set! floors (cadr item) (cons (car item) (vector-ref floors (cadr item)))))
               (cdr state))
      (let loop ((floor-idx 0))
        (cond ((= floor-idx 4) #t)
              (else
               (let ((floor (vector-ref floors floor-idx)))
                 (let ((generators (filter (lambda (item) (string-suffix? "g" (symbol->string item))) floor))
                       (microchips (filter (lambda (item) (string-suffix? "m" (symbol->string item))) floor)))
                   (cond ((null? generators) (loop (+ floor-idx 1)))
                         (else
                          (let ((fried? #f))
                            (for-each (lambda (chip)
                                       (let ((gen-name (string->symbol (string-replace (symbol->string chip) "m" "g"))))
                                         (if (not (member gen-name generators))
                                             (set! fried? #t))))
                                     microchips)
                            (if fried? #f (loop (+ floor-idx 1)))))))))))))

  (define (generate-next-states state)
    (let* ((elevator-floor (car state))
           (items (cdr state))
           (current-floor-items (filter (lambda (item) (= (cadr item) elevator-floor)) items))
           (next-states (list)))
      (define (add-state new-elevator-floor new-items)
        (let ((new-state (cons new-elevator-floor new-items)))
          (if (valid-state? new-state)
              (set! next-states (cons new-state next-states)))))
      (define (move-items items-to-move direction)
        (let ((new-elevator-floor (+ elevator-floor direction))
              (new-items (map (lambda (item)
                                (if (member item items-to-move)
                                    (list (car item) new-elevator-floor)
                                    item))
                              items)))
          (add-state new-elevator-floor new-items)))
      (cond ((= elevator-floor 0)
             (for-each (lambda (item1)
                         (move-items (list item1) 1)
                         (for-each (lambda (item2)
                                     (if (not (eq? item1 item2))
                                         (move-items (list item1 item2) 1)))
                                   current-floor-items))
                       current-floor-items))
            ((= elevator-floor 3)
             (for-each (lambda (item1)
                         (move-items (list item1) -1)
                         (for-each (lambda (item2)
                                     (if (not (eq? item1 item2))
                                         (move-items (list item1 item2) -1)))
                                   current-floor-items))
                       current-floor-items))
            (else
             (for-each (lambda (item1)
                         (move-items (list item1) 1)
                         (move-items (list item1) -1)
                         (for-each (lambda (item2)
                                     (if (not (eq? item1 item2))
                                         (move-items (list item1 item2) 1)
                                         (move-items (list item1 item2) -1)))
                                   current-floor-items))
                       current-floor-items)))
      next-states))

  (define (bfs initial-state)
    (let ((queue (list (cons initial-state 0)))
          (visited (make-hash)))
      (hash-set! visited initial-state #t)
      (let loop ()
        (if (null? queue)
            #f
            (let* ((current (car queue))
                   (state (car current))
                   (steps (cdr current)))
              (if (all-items-on-fourth-floor? state)
                  steps
                  (let ((next-states (generate-next-states state)))
                    (set! queue (append (cdr queue)
                                        (filter (lambda (next-state)
                                                  (if (hash-has-key? visited next-state)
                                                      #f
                                                      (begin (hash-set! visited next-state #t) #t)))
                                                (map (lambda (next-state) (cons next-state (+ steps 1))) next-states))))
                    (loop))))))))

  (define (all-items-on-fourth-floor? state)
    (let ((items (cdr state)))
      (every (lambda (item) (= (cadr item) 3)) items)))

  (let* ((lines (file->lines input-file))
         (items (parse-input lines))
         (initial-state (cons 0 items)))
    (if part2?
        (let ((new-items (append items (list (list 'eleriumg 0) (list 'eleriumm 0) (list 'dilithiumg 0) (list 'dilithiumm 0)))))
          (bfs (cons 0 new-items)))
        (bfs initial-state))))

(define (string-split str delim)
  (let loop ((start 0) (result '()))
    (let ((pos (string-index str delim start)))
      (if pos
          (loop (+ pos (string-length delim)) (cons (substring str start pos) result))
          (reverse (cons (substring str start) result))))))

(define (string-suffix? suffix str)
  (let ((suffix-len (string-length suffix))
        (str-len (string-length str)))
    (and (>= str-len suffix-len)
         (string=? (substring str (- str-len suffix-len)) suffix))))

(define (string-replace str old new)
  (let ((pos (string-index str old)))
    (if pos
        (string-append (substring str 0 pos) new (substring str (+ pos (string-length old))))
        str)))

(define (file->lines filename)
  (with-input-from-file filename
    (lambda ()
      (let loop ((lines '()))
        (let ((line (read-line)))
          (if (eof-object? line)
              (reverse lines)
              (loop (cons line lines))))))))

(display (solve "input.txt" #f))
(newline)
(display (solve "input.txt" #t))
(newline)
