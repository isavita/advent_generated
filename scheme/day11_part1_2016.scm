
(define (solve input-file)
  (let* ((input (with-input-from-file input-file read))
         (initial-state (parse-input input))
         (goal-state (goal-state initial-state))
         (queue (list (list 0 initial-state)))
         (visited (make-hash)))
    (hash-set! visited (state-hash initial-state) #t)
    (letrec ((bfs (lambda ()
                     (if (null? queue)
                         #f
                         (let* ((current (car queue))
                                (steps (car current))
                                (state (cadr current)))
                           (if (equal? state goal-state)
                               steps
                               (let ((next-states (generate-next-states state)))
                                 (for-each
                                  (lambda (next-state)
                                    (let ((hash (state-hash next-state)))
                                      (unless (hash-has-key? visited hash)
                                        (hash-set! visited hash #t)
                                        (set! queue (append queue (list (list (1+ steps) next-state)))))))
                                  next-states)
                                 (set! queue (cdr queue))
                                 (bfs))))))))
      (bfs))))

(define (parse-input input)
  (let ((floors (make-vector 4 '())))
    (for-each
     (lambda (line)
       (let* ((parts (string-split line " "))
              (floor-num (string->number (substring (car parts) 1)))
              (floor-index (- floor-num 1)))
         (for-each
          (lambda (part)
            (cond ((string=? part "generator")
                   (vector-set! floors floor-index (cons (list (string-append (string-ref (cadr parts) 0) "G") floor-index) (vector-ref floors floor-index))))
                  ((string=? part "microchip")
                   (vector-set! floors floor-index (cons (list (string-append (string-ref (cadr parts) 0) "M") floor-index) (vector-ref floors floor-index))))))
          parts)))
     input)
    (list 0 floors)))

(define (goal-state initial-state)
  (let* ((floors (cadr initial-state))
         (num-floors (vector-length floors))
         (goal-floors (make-vector num-floors '())))
    (for-each
     (lambda (floor)
       (for-each
        (lambda (item)
          (vector-set! goal-floors (- num-floors 1) (cons item (vector-ref goal-floors (- num-floors 1)))))
        floor))
     floors)
    (list (- num-floors 1) goal-floors)))

(define (generate-next-states state)
  (let* ((elevator-floor (car state))
         (floors (cadr state))
         (next-states '()))
    (for-each
     (lambda (direction)
       (let ((next-floor (+ elevator-floor direction)))
         (when (and (>= next-floor 0) (< next-floor (vector-length floors)))
           (let ((current-floor-items (vector-ref floors elevator-floor)))
             (for-each
              (lambda (item1)
                (set! next-states (append next-states (list (move-items state (list item1) next-floor)))))
              current-floor-items)
             (for-each
              (lambda (item1)
                (for-each
                 (lambda (item2)
                   (when (not (equal? item1 item2))
                     (set! next-states (append next-states (list (move-items state (list item1 item2) next-floor))))))
                 current-floor-items))
              current-floor-items)))))
     (list -1 1))
    (filter valid-state? next-states)))

(define (move-items state items next-floor)
  (let* ((elevator-floor (car state))
         (floors (cadr state))
         (new-floors (vector-copy floors)))
    (let ((current-floor-items (vector-ref new-floors elevator-floor)))
      (set! current-floor-items (filter (lambda (item) (not (member item items))) current-floor-items))
      (vector-set! new-floors elevator-floor current-floor-items))
    (let ((next-floor-items (vector-ref new-floors next-floor)))
      (set! next-floor-items (append next-floor-items items))
      (vector-set! new-floors next-floor next-floor-items))
    (list next-floor new-floors)))

(define (valid-state? state)
  (let ((floors (cadr state)))
    (letrec ((valid-floor? (lambda (floor)
                             (let ((generators (filter (lambda (item) (string=? (substring (car item) 1 2) "G")) floor))
                                   (microchips (filter (lambda (item) (string=? (substring (car item) 1 2) "M")) floor)))
                               (if (null? generators)
                                   #t
                                   (every?
                                    (lambda (microchip)
                                      (let ((matching-generator (find (lambda (generator) (string=? (substring (car generator) 0 1) (substring (car microchip) 0 1))) generators)))
                                        (or (null? matching-generator) (not (null? generators)))))
                                    microchips))))))
      (every? valid-floor? floors))))

(define (state-hash state)
  (let* ((elevator-floor (car state))
         (floors (cadr state))
         (floor-hashes (map (lambda (floor)
                              (sort (map car floor) string<?))
                            floors)))
    (string-append (number->string elevator-floor) ":" (string-join (map (lambda (hash) (string-join hash ",")) floor-hashes) ";"))))

(define (string-split str delim)
  (let loop ((start 0) (result '()))
    (let ((pos (string-index str delim start)))
      (if pos
          (loop (+ pos (string-length delim)) (cons (substring str start pos) result))
          (reverse (cons (substring str start) result))))))

(display (solve "input.txt"))
(newline)
