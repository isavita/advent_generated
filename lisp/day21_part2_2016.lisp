
(defun read-file-lines (filename)
  (with-open-file (stream filename :direction :input)
    (loop for line = (read-line stream nil nil)
          while line
          collect line)))

(defun split-string (string delimiter)
  (loop for start = 0 then (1+ end)
        for end = (position delimiter string :start start)
        collect (subseq string start (or end (length string)))
        while end))

(defun string-starts-with-p (string prefix)
  (and (>= (length string) (length prefix))
       (string= string prefix :end1 (length prefix))))

(defun swap-positions (pw x y)
  (let ((new-pw (copy-seq pw)))
    (rotatef (aref new-pw x) (aref new-pw y))
    new-pw))

(defun swap-letters (pw x y)
  (let* ((idx-x (position x pw :test #'char=))
         (idx-y (position y pw :test #'char=)))
    (swap-positions pw idx-x idx-y)))

(defun rotate-vector (pw steps)
  (let* ((len (length pw))
         (effective-steps (mod steps len)))
    (if (zerop effective-steps)
        pw
        (concatenate 'vector
                     (subseq pw (- len effective-steps))
                     (subseq pw 0 (- len effective-steps))))))

(defun rotate-letter (pw ch)
  (let* ((idx (position ch pw :test #'char=))
         (steps (+ idx 1 (if (>= idx 4) 1 0))))
    (rotate-vector pw steps)))

(defun derotate-letter-steps (current-index)
  (case current-index
    (0 -1)
    (1 -1)
    (2 2)
    (3 -2)
    (4 1)
    (5 -3)
    (6 0)
    (7 -4)
    (otherwise (error "Invalid index for derotate-letter"))))

(defun derotate-letter (pw ch)
  (let* ((idx (position ch pw :test #'char=))
         (steps (derotate-letter-steps idx)))
    (rotate-vector pw steps)))

(defun reverse-vector-segment (pw x y)
  (let* ((prefix (subseq pw 0 x))
         (segment (subseq pw x (1+ y)))
         (reversed-segment (coerce (nreverse (coerce segment 'list)) 'vector))
         (suffix (subseq pw (1+ y))))
    (concatenate 'vector prefix reversed-segment suffix)))

(defun move-char (pw from-idx to-idx)
  (let* ((char-to-move (aref pw from-idx))
         (pw-without-char (concatenate 'vector
                                       (subseq pw 0 from-idx)
                                       (subseq pw (1+ from-idx)))))
    (concatenate 'vector
                 (subseq pw-without-char 0 to-idx)
                 (vector char-to-move)
                 (subseq pw-without-char to-idx))))

(defun scramble (pw instructions direction)
  (let ((current-pw (copy-seq pw)))
    (loop for instruction in (if (< direction 0)
                                 (reverse instructions)
                                 instructions)
          for parts = (split-string instruction #\Space)
          do (cond
               ((string-starts-with-p instruction "swap position")
                (let ((x (parse-integer (nth 2 parts)))
                      (y (parse-integer (nth 5 parts))))
                  (setf current-pw (swap-positions current-pw x y))))
               ((string-starts-with-p instruction "swap letter")
                (let ((x (char (nth 2 parts) 0))
                      (y (char (nth 5 parts) 0)))
                  (setf current-pw (swap-letters current-pw x y))))
               ((string-starts-with-p instruction "rotate based")
                (let ((char-to-rotate (char (nth 6 parts) 0)))
                  (if (> direction 0)
                      (setf current-pw (rotate-letter current-pw char-to-rotate))
                      (setf current-pw (derotate-letter current-pw char-to-rotate)))))
               ((string-starts-with-p instruction "rotate")
                (let* ((steps (parse-integer (nth 2 parts)))
                       (effective-steps (if (string= (nth 1 parts) "left")
                                            (- steps)
                                            steps)))
                  (if (< direction 0)
                      (setf effective-steps (- effective-steps)))
                  (setf current-pw (rotate-vector current-pw effective-steps))))
               ((string-starts-with-p instruction "reverse")
                (let ((x (parse-integer (nth 2 parts)))
                      (y (parse-integer (nth 4 parts))))
                  (setf current-pw (reverse-vector-segment current-pw x y))))
               ((string-starts-with-p instruction "move")
                (let ((x (parse-integer (nth 2 parts)))
                      (y (parse-integer (nth 5 parts))))
                  (if (< direction 0)
                      (rotatef x y))
                  (setf current-pw (move-char current-pw x y))))
               (t (error "Unknown instruction: ~a" instruction))))
    current-pw))

(defun unscramble (pw instructions)
  (scramble pw instructions -1))

(defun main ()
  (let* ((instructions (read-file-lines "input.txt"))
         (initial-password (coerce "fbgdceah" 'vector))
         (unscrambled-password (unscramble initial-password instructions)))
    (format t "~a~%" (coerce unscrambled-password 'string))))

(main)
