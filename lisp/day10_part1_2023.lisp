
(defstruct (coord (:constructor make-coord (x y)))
  (x 0 :type fixnum)
  (y 0 :type fixnum))

(defun coord-add (c1 c2)
  (make-coord (+ (coord-x c1) (coord-x c2))
              (+ (coord-y c1) (coord-y c2))))

(defun coord-opposite (c)
  (make-coord (- (coord-x c)) (- (coord-y c))))

(defun coord-equal (c1 c2)
  (and (= (coord-x c1) (coord-x c2))
       (= (coord-y c1) (coord-y c2))))

(defconstant +undefined+ (make-coord 0 0))
(defconstant +top+ (make-coord 0 -1))
(defconstant +right+ (make-coord 1 0))
(defconstant +bottom+ (make-coord 0 1))
(defconstant +left+ (make-coord -1 0))

(defconstant +empty+ #\.)
(defconstant +start+ #\S)
(defconstant +vertical+ #\|)
(defconstant +horizontal+ #\-)
(defconstant +top-left-corner+ #\J)
(defconstant +top-right-corner+ #\L)
(defconstant +bottom-left-corner+ #\7)
(defconstant +bottom-right-corner+ #\F)

(defconstant +tile-to-pipe+
  (let ((ht (make-hash-table :test 'eql)))
    (setf (gethash +vertical+ ht) (list +top+ +bottom+))
    (setf (gethash +horizontal+ ht) (list +left+ +right+))
    (setf (gethash +top-left-corner+ ht) (list +top+ +left+))
    (setf (gethash +top-right-corner+ ht) (list +top+ +right+))
    (setf (gethash +bottom-left-corner+ ht) (list +bottom+ +left+))
    (setf (gethash +bottom-right-corner+ ht) (list +bottom+ +right+))
    ht))

(defun get-pipe-from-tile (tile-char)
  (gethash tile-char +tile-to-pipe+ nil))

(defun read-file-lines (filename)
  (with-open-file (stream filename :direction :input :if-does-not-exist :error)
    (loop for line = (read-line stream nil nil)
          while line
          collect line)))

(defun build-grid (input-lines)
  (let* ((lines-vector (coerce input-lines 'vector))
         (height (length lines-vector))
         (width (length (aref lines-vector 0)))
         (grid (make-array (list height width) :element-type 'character))
         (start-coord +undefined+))
    (dotimes (y height)
      (let ((line (aref lines-vector y)))
        (dotimes (x width)
          (let ((char (char line x)))
            (setf (aref grid y x) char)
            (when (char= char +start+)
              (setf start-coord (make-coord x y)))))))
    (values grid start-coord)))

(defun get-pipe-from-neighbors (grid start)
  (let ((pipe-directions nil)
        (height (array-dimension grid 0))
        (width (array-dimension grid 1)))
    (dolist (dir (list +top+ +right+ +bottom+ +left+))
      (let* ((neighbor-coord (coord-add start dir))
             (nx (coord-x neighbor-coord))
             (ny (coord-y neighbor-coord)))
        (when (and (>= ny 0) (< ny height)
                   (>= nx 0) (< nx width))
          (let* ((neighbor-char (aref grid ny nx))
                 (neighbor-pipe (get-pipe-from-tile neighbor-char))
                 (opposite-dir (coord-opposite dir)))
            (dolist (d neighbor-pipe)
              (when (coord-equal d opposite-dir)
                (push dir pipe-directions)
                (return)))))))
    (nreverse pipe-directions)))

(defun path-finding-count (grid start)
  (let* ((start-pipe (get-pipe-from-neighbors grid start))
         (previous-dir (first start-pipe))
         (current-coord (coord-add start previous-dir))
         (step-count 1))
    (loop
      (when (coord-equal current-coord start)
        (return step-count))
      (incf step-count)
      (let* ((current-tile (aref grid (coord-y current-coord) (coord-x current-coord)))
             (current-pipe (get-pipe-from-tile current-tile))
             (opposite-previous-dir (coord-opposite previous-dir)))
        (dolist (dir current-pipe)
          (unless (coord-equal dir opposite-previous-dir)
            (setf previous-dir dir)
            (setf current-coord (coord-add current-coord dir))
            (return)))))))

(defun solve (input-lines)
  (multiple-value-bind (grid start) (build-grid input-lines)
    (let ((path-length (path-finding-count grid start)))
      (/ path-length 2))))

(defun main ()
  (let ((input-lines (read-file-lines "input.txt")))
    (format t "~a~%" (solve input-lines))))

#+sbcl (main)
#+clozure (main)
#+ecl (main)
#+gcl (main)
#+lispworks (main)
#+allegro (main)
