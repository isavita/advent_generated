
(in-package :cl-user)

(defun coord-x (c) (first c))
(defun coord-y (c) (second c))
(defun make-coord (x y) (list x y))
(defun coord-equal (c1 c2) (equal c1 c2))
(defun coord-add (c1 c2) (list (+ (coord-x c1) (coord-x c2)) (+ (coord-y c1) (coord-y c2))))
(defun coord-subtract (c1 c2) (list (- (coord-x c1) (coord-x c2)) (- (coord-y c1) (coord-y c2))))
(defun coord-opposite (c) (list (- (coord-x c)) (- (coord-y c))))

(defstruct (priority-queue (:constructor make-pq (compare-fn &optional (initial-capacity 16))))
  (data (make-array initial-capacity :fill-pointer 0 :adjustable t))
  (compare-fn #'< :type function))

(defun pq-empty-p (pq)
  (zerop (fill-pointer (priority-queue-data pq))))

(defun pq-push (pq item)
  (let* ((data (priority-queue-data pq))
         (compare-fn (priority-queue-compare-fn pq)))
    (vector-push-extend item data)
    (loop for i = (1- (fill-pointer data)) then parent-idx
          while (and (> i 0)
                     (funcall compare-fn (aref data i) (aref data (setf parent-idx (floor (1- i) 2)))))
          do (rotatef (aref data i) (aref data parent-idx)))))

(defun pq-pop (pq)
  (let* ((data (priority-queue-data pq))
         (compare-fn (priority-queue-compare-fn pq)))
    (when (pq-empty-p pq)
      (return-from pq-pop nil))
    (let ((min-item (aref data 0)))
      (setf (aref data 0) (aref data (1- (fill-pointer data))))
      (vector-pop data)
      (loop for i = 0 then smallest-idx-found
            for left-child = (+ (* 2 i) 1)
            for right-child = (+ (* 2 i) 2)
            for smallest-idx-found = i
            do (when (and (< left-child (fill-pointer data))
                          (funcall compare-fn (aref data left-child) (aref data smallest-idx-found)))
                 (setf smallest-idx-found left-child))
               (when (and (< right-child (fill-pointer data))
                          (funcall compare-fn (aref data right-child) (aref data smallest-idx-found)))
                 (setf smallest-idx-found right-child))
               (when (= smallest-idx-found i)
                 (return))
               (rotatef (aref data i) (aref data smallest-idx-found))
               (setf i smallest-idx-found))
      min-item)))

(defstruct (grid (:constructor make-grid (width height data)))
  (width 0 :type fixnum)
  (height 0 :type fixnum)
  (data nil :type hash-table))

(defun grid-neighbors4 (grid coord)
  (let* ((directions (list (make-coord 0 -1) (make-coord -1 0) (make-coord 0 1) (make-coord 1 0)))
         (width (grid-width grid))
         (height (grid-height grid))
         (neighbors nil))
    (dolist (direction directions)
      (let ((neighbor (coord-add coord direction)))
        (when (and (>= (coord-x neighbor) 0) (< (coord-x neighbor) width)
                   (>= (coord-y neighbor) 0) (< (coord-y neighbor) height))
          (push neighbor neighbors))))
    (nreverse neighbors)))

(defun make-grid-from-input (input-lines)
  (let* ((height (length input-lines))
         (width (length (first input-lines)))
         (data (make-hash-table :test 'equal)))
    (loop for y from 0 below height
          for line = (nth y input-lines)
          do (loop for x from 0 below width
                   for char = (char line x)
                   do (setf (gethash (make-coord x y) data)
                            (digit-char-p char))))
    (make-grid width height data)))

(defun manhattan-distance (c1 c2)
  (+ (abs (- (coord-x c1) (coord-x c2)))
     (abs (- (coord-y c1) (coord-y c2)))))

(defun a-star-constrained (grid start goal min-straight max-straight)
  (let* ((start-info (list start (make-coord 0 0) 0))
         (frontier (make-pq (lambda (a b) (< (car a) (car b)))))
         (cost-so-far (make-hash-table :test 'equal)))
    (pq-push frontier (cons 0 start-info))
    (setf (gethash start-info cost-so-far) 0)
    (loop while (not (pq-empty-p frontier))
          do (let* ((current-entry (pq-pop frontier))
                    (current-info (cdr current-entry))
                    (current-coord (first current-info))
                    (current-dir (second current-info))
                    (current-num-straight (third current-info)))
               (when (coord-equal current-coord goal)
                 (return-from a-star-constrained (gethash current-info cost-so-far)))
               (dolist (neighbor (grid-neighbors4 grid current-coord))
                 (let* ((new-dir (coord-subtract neighbor current-coord))
                        (new-num-straight (if (coord-equal new-dir current-dir)
                                               (1+ current-num-straight)
                                               1))
                        (neighbor-info (list neighbor new-dir new-num-straight))
                        (new-cost (+ (gethash current-info cost-so-far)
                                     (gethash neighbor (grid-data grid)))))
                   (when (or (not (gethash neighbor-info cost-so-far))
                             (< new-cost (gethash neighbor-info cost-so-far)))
                     (when (and (or (>= current-num-straight min-straight)
                                    (coord-equal new-dir current-dir)
                                    (coord-equal current-coord start))
                                (<= new-num-straight max-straight)
                                (not (coord-equal new-dir (coord-opposite current-dir))))
                       (setf (gethash neighbor-info cost-so-far) new-cost)
                       (let ((priority (+ new-cost (manhattan-distance neighbor goal))))
                         (pq-push frontier (cons priority neighbor-info)))))))))
    -1))

(defun solve (input-lines)
  (let* ((grid (make-grid-from-input input-lines))
         (start (make-coord 0 0))
         (goal (make-coord (1- (grid-width grid)) (1- (grid-height grid)))))
    (a-star-constrained grid start goal 0 3)))

(defun read-file-lines (file-name)
  (with-open-file (stream file-name :direction :input)
    (loop for line = (read-line stream nil nil)
          while line
          collect line)))

(defun main ()
  (let ((input-data (read-file-lines "input.txt")))
    (format t "~a~%" (solve input-data))))

(main)
