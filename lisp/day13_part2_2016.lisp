
(defun read-input (filepath)
  (with-open-file (stream filepath :direction :input)
    (parse-integer (read-line stream nil ""))))

(defun is-wall (x y favorite-number)
  (let* ((value (+ (* x x) (* 3 x) (* 2 x y) y (* y y) favorite-number)))
    (oddp (logcount value))))

(defconstant +directions+ '((0 1) (0 -1) (1 0) (-1 0)))

(defun make-queue () (cons nil nil))

(defun enqueue (item queue)
  (setf (cdr queue) (cons item (cdr queue)))
  queue)

(defun dequeue (queue)
  (when (null (car queue))
    (setf (car queue) (nreverse (cdr queue)))
    (setf (cdr queue) nil))
  (when (car queue)
    (pop (car queue))))

(defun queue-empty-p (queue)
  (and (null (car queue)) (null (cdr queue))))

(defun shortest-path (start-x start-y target-x target-y favorite-number)
  (let ((queue (make-queue))
        (visited (make-hash-table :test 'equal)))
    (enqueue (list start-x start-y 0) queue)
    (setf (gethash (list start-x start-y) visited) t)
    (loop until (queue-empty-p queue) do
      (let* ((current (dequeue queue))
             (x (first current))
             (y (second current))
             (steps (third current)))
        (when (and (= x target-x) (= y target-y))
          (return-from shortest-path steps))
        (loop for (dx dy) in +directions+ do
          (let* ((nx (+ x dx))
                 (ny (+ y dy))
                 (coord (list nx ny)))
            (when (and (>= nx 0) (>= ny 0)
                       (not (gethash coord visited))
                       (not (is-wall nx ny favorite-number)))
              (setf (gethash coord visited) t)
              (enqueue (list nx ny (+ steps 1)) queue))))))
    -1))

(defun count-reachable-locations (start-x start-y max-steps favorite-number)
  (let ((queue (make-queue))
        (visited (make-hash-table :test 'equal))
        (count 0))
    (enqueue (list start-x start-y 0) queue)
    (setf (gethash (list start-x start-y) visited) t)
    (loop until (queue-empty-p queue) do
      (let* ((current (dequeue queue))
             (x (first current))
             (y (second current))
             (steps (third current)))
        (when (> steps max-steps)
          (return))
        (incf count)
        (loop for (dx dy) in +directions+ do
          (let* ((nx (+ x dx))
                 (ny (+ y dy))
                 (coord (list nx ny)))
            (when (and (>= nx 0) (>= ny 0)
                       (not (gethash coord visited))
                       (not (is-wall nx ny favorite-number)))
              (setf (gethash coord visited) t)
              (enqueue (list nx ny (+ steps 1)) queue))))))
    count))

(defun main ()
  (let* ((favorite-number (read-input "input.txt"))
         (start-x 1) (start-y 1)
         (target-x 31) (target-y 39)
         (max-steps 50)
         (fewest-steps (shortest-path start-x start-y target-x target-y favorite-number))
         (reachable-locations (count-reachable-locations start-x start-y max-steps favorite-number)))
    (format t "Fewest number of steps required to reach 31,39: ~a~%" fewest-steps)
    (format t "Number of locations reachable in at most 50 steps: ~a~%" reachable-locations)))

(main)
