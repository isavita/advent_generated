
(defun starts-with-prefix (prefix string)
  (and (<= (length prefix) (length string))
       (string= prefix string :end2 (length prefix))))

(defun split-string (str delim)
  (loop for start = 0 then (1+ end)
        for end = (position delim str :start start)
        collect (string-trim '(#\Space) (subseq str start (or end (length str))))
        while end))

(defun solve ()
  (let ((a 0) (b 0) (c 0)
        (program-data nil)
        (output-vals nil))

    (with-open-file (f "input.txt" :direction :input)
      (loop for line = (read-line f nil nil)
            while line
            do (let ((trimmed-line (string-trim '(#\Space #\Tab #\Newline) line)))
                 (unless (string= trimmed-line "")
                   (cond
                     ((starts-with-prefix "Register A:" trimmed-line)
                      (setf a (parse-integer (subseq trimmed-line (length "Register A:")))))
                     ((starts-with-prefix "Register B:" trimmed-line)
                      (setf b (parse-integer (subseq trimmed-line (length "Register B:")))))
                     ((starts-with-prefix "Register C:" trimmed-line)
                      (setf c (parse-integer (subseq trimmed-line (length "Register C:")))))
                     ((starts-with-prefix "Program:" trimmed-line)
                      (setf program-data (mapcar #'parse-integer
                                                 (split-string (subseq trimmed-line (length "Program:")) #\,)))))))))

    (labels ((get-combo-val (op)
               (cond
                 ((<= op 3) op)
                 ((= op 4) a)
                 ((= op 5) b)
                 ((= op 6) c)
                 (t (error "invalid combo operand")))))

      (let ((ip 0))
        (loop while (< ip (length program-data))
              do (let ((opcode (elt program-data ip)))
                   (unless (< (1+ ip) (length program-data))
                     (return))
                   (let ((operand (elt program-data (1+ ip))))
                     (cond
                       ((= opcode 0)
                        (let ((den (get-combo-val operand)))
                          (setf a (if (= den 0) 0 (floor a (ash 1 den)))))
                        (incf ip 2))
                       ((= opcode 1)
                        (setf b (logxor b operand))
                        (incf ip 2))
                       ((= opcode 2)
                        (setf b (mod (get-combo-val operand) 8))
                        (incf ip 2))
                       ((= opcode 3)
                        (setf ip (if (/= a 0) operand (+ ip 2))))
                       ((= opcode 4)
                        (setf b (logxor b c))
                        (incf ip 2))
                       ((= opcode 5)
                        (push (format nil "~a" (mod (get-combo-val operand) 8)) output-vals)
                        (incf ip 2))
                       ((= opcode 6)
                        (setf b (floor a (ash 1 (get-combo-val operand))))
                        (incf ip 2))
                       ((= opcode 7)
                        (setf c (floor a (ash 1 (get-combo-val operand))))
                        (incf ip 2))
                       (t (return))))))))

    (format t "~{~a~^,~}~%" (nreverse output-vals))))

(defun main ()
  (solve))

(main)
