
(defclass assembunny-interpreter ()
  ((instructions :initarg :instructions :accessor instructions)
   (registers :initform (make-hash-table :test 'eq) :accessor registers)
   (ip :initform 0 :accessor ip)))

(defun get-value (interpreter arg)
  (if (numberp arg)
      arg
      (gethash arg (registers interpreter) 0)))

(defmethod toggle-instruction ((interpreter assembunny-interpreter) index)
  (when (and (>= index 0) (< index (length (instructions interpreter))))
    (let* ((current-instr-list (svref (instructions interpreter) index))
           (op (car current-instr-list)))
      (setf (car current-instr-list)
            (case op
              (inc 'dec)
              ((dec tgl out) 'inc)
              (jnz 'cpy)
              (cpy 'jnz))))))

(defmethod run ((interpreter assembunny-interpreter))
  (loop while (< (ip interpreter) (length (instructions interpreter)))
        do (let* ((instr (svref (instructions interpreter) (ip interpreter)))
                  (op (car instr))
                  (args (cdr instr)))
             (case op
               (cpy (let ((val (get-value interpreter (car args)))
                          (target-reg (cadr args)))
                      (when (symbolp target-reg)
                        (setf (gethash target-reg (registers interpreter)) val))))
               (inc (let ((reg (car args)))
                      (when (symbolp reg)
                        (incf (gethash reg (registers interpreter) 0)))))
               (dec (let ((reg (car args)))
                      (when (symbolp reg)
                        (decf (gethash reg (registers interpreter) 0)))))
               (jnz (let ((condition-val (get-value interpreter (car args)))
                          (offset (get-value interpreter (cadr args))))
                      (when (/= condition-val 0)
                        (incf (ip interpreter) (- offset 1)))))
               (tgl (let ((offset (get-value interpreter (car args))))
                      (toggle-instruction interpreter (+ (ip interpreter) offset)))))
             (incf (ip interpreter)))))

(defmethod get-register ((interpreter assembunny-interpreter) name)
  (gethash name (registers interpreter) 0))

(defmethod set-register ((interpreter assembunny-interpreter) name value)
  (setf (gethash name (registers interpreter)) value))

(defun my-split-string (string separator)
  (loop for start = 0 then (1+ end)
        for end = (position separator string :start start)
        collect (subseq string start (or end (length string)))
        while end))

(defun parse-instructions (input-string)
  (coerce (loop for line in (my-split-string input-string #\Newline)
                unless (string= line "")
                collect (let* ((parts (my-split-string line #\Space))
                               (op (intern (string-upcase (car parts))))
                               (args (mapcar (lambda (arg-str)
                                               (if (ignore-errors (parse-integer arg-str))
                                                   (parse-integer arg-str)
                                                   (intern (string-upcase arg-str))))
                                             (cdr parts))))
                          (cons op args)))
          'vector))

(defun main ()
  (let* ((input-content (with-open-file (f "input.txt" :direction :input :if-does-not-exist :error)
                          (let ((seq (make-string (file-length f))))
                            (read-sequence seq f)
                            seq)))
         (instructions (parse-instructions input-content))
         (interpreter (make-instance 'assembunny-interpreter :instructions instructions)))
    (set-register interpreter 'a 7)
    (run interpreter)
    (format t "~a~%" (get-register interpreter 'a))))

(main)
