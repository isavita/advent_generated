
(defun read-map (filename)
  (with-open-file (f filename :direction :input)
    (loop for line = (read-line f nil nil)
          while line
          collect (coerce line 'list))))

(defun neighbors (x y)
  (list (cons (+ x 1) y)
        (cons (- x 1) y)
        (cons x (+ y 1))
        (cons x (- y 1))))

(defun find-interests (layout)
  (let ((interests (make-hash-table :test 'eql)))
    (loop for y from 0 below (length layout)
          for row = (nth y layout)
          do (loop for x from 0 below (length row)
                   for char = (nth x row)
                   do (when (digit-char-p char)
                        (setf (gethash char interests) (cons x y)))))
    interests))

(defun shortest-path (layout start-coord goal-coord)
  (let* ((queue (list (list 0 start-coord)))
         (visited (make-hash-table :test 'equal)))
    (setf (gethash start-coord visited) t)
    (loop
      (when (null queue) (return most-positive-fixnum))
      (let* ((current-item (pop queue))
             (cost (car current-item))
             (current-pos (cadr current-item))
             (cx (car current-pos))
             (cy (cdr current-pos)))
        (when (equal current-pos goal-coord) (return cost))
        (loop for next-pos in (neighbors cx cy)
              for nx = (car next-pos)
              for ny = (cdr next-pos)
              do (when (and (>= ny 0) (< ny (length layout))
                            (>= nx 0) (< nx (length (car layout)))
                            (char/= (nth nx (nth ny layout)) #\#)
                            (not (gethash next-pos visited)))
                   (setf (gethash next-pos visited) t)
                   (setf queue (append queue (list (list (+ cost 1) next-pos))))))))))

(defun generate-permutations (lst)
  (if (null lst)
      (list nil)
      (loop for x in lst
            nconc (loop for p in (generate-permutations (remove x lst :count 1))
                         collect (cons x p)))))

(defun solve-tsp-with-return (distances)
  (let* ((nodes-list (sort (loop for k being the hash-keys of distances collect k) #'char<))
         (start-node #\0)
         (other-nodes (remove start-node nodes-list :test #'char=))
         (min-path-length most-positive-fixnum))
    (loop for perm in (generate-permutations other-nodes)
          do (let ((path-length 0)
                   (current-node start-node))
               (loop for next-node in perm
                     do (incf path-length (gethash next-node (gethash current-node distances)))
                        (setf current-node next-node))
               (incf path-length (gethash start-node (gethash current-node distances)))
               (setf min-path-length (min min-path-length path-length))))
    min-path-length))

(defun main ()
  (let* ((layout (read-map "input.txt"))
         (interests (find-interests layout))
         (distances (make-hash-table :test 'eql)))
    (loop for i being the hash-keys of interests
          do (setf (gethash i distances) (make-hash-table :test 'eql)))
    (loop for i being the hash-keys of interests
          for i-coord = (gethash i interests)
          do (loop for j being the hash-keys of interests
                   for j-coord = (gethash j interests)
                   do (unless (char= i j)
                        (setf (gethash j (gethash i distances))
                              (shortest-path layout i-coord j-coord)))))
    (let ((answer (solve-tsp-with-return distances)))
      (format t "~a~%" answer))))

(main)
