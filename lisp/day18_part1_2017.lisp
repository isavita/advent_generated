
(defun read-instructions (filename)
  (with-open-file (f filename :direction :input)
    (loop for line = (read-line f nil nil)
          while line
          collect (with-input-from-string (s line)
                    (loop for part = (read s nil :eof)
                          until (eq part :eof)
                          collect part)) into instrs
          finally (return (coerce instrs 'vector)))))

(defun main ()
  (let* ((instructions (read-instructions "input.txt"))
         (registers (make-hash-table :test 'eql))
         (current-instruction 0)
         (last-sound 0))
    (loop
      (when (or (< current-instruction 0)
                (>= current-instruction (length instructions)))
        (return))
      (let* ((instr-parts (aref instructions current-instruction))
             (command (car instr-parts))
             (reg-name (cadr instr-parts))
             (val-arg (caddr instr-parts)))
        (flet ((get-value (arg)
                 (if (symbolp arg)
                     (gethash arg registers 0)
                     arg)))
          (let ((reg-current-val (gethash reg-name registers 0))
                (operand-val (if val-arg (get-value val-arg) nil))
                (next-instruction-offset 1))
            (case command
              (snd (setf last-sound reg-current-val))
              (set (setf (gethash reg-name registers) operand-val))
              (add (incf (gethash reg-name registers) operand-val))
              (mul (setf (gethash reg-name registers) (* reg-current-val operand-val)))
              (mod (setf (gethash reg-name registers) (mod reg-current-val operand-val)))
              (rcv (when (/= reg-current-val 0)
                     (print last-sound)
                     (return)))
              (jgz (when (> reg-current-val 0)
                     (setf next-instruction-offset operand-val))))
            (incf current-instruction next-instruction-offset)))))))

(main)
