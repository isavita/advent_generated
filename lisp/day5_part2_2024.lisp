
(defun split-string (string delimiter)
  (loop for start = 0 then (1+ end)
        for end = (position delimiter string :start start)
        collect (subseq string start (or end (length string)))
        while end))

(defun parse-line-rules (line)
  (let ((parts (split-string line #\|)))
    (list (parse-integer (first parts))
          (parse-integer (second parts)))))

(defun parse-line-update (line)
  (loop for part in (split-string line #\,)
        collect (parse-integer part)))

(defun read-input (filename)
  (with-open-file (f filename :direction :input)
    (let ((rules nil)
          (updates nil)
          (reading-rules t))
      (loop for line = (read-line f nil)
            while line
            do (let ((trimmed-line (string-trim '(#\Space #\Tab #\Newline #\Return) line)))
                 (when (not (string= trimmed-line ""))
                   (if reading-rules
                       (if (find #\| trimmed-line)
                           (push (parse-line-rules trimmed-line) rules)
                           (progn (setf reading-rules nil)
                                  (push (parse-line-update trimmed-line) updates)))
                       (push (parse-line-update trimmed-line) updates)))))
      (values (nreverse rules) (nreverse updates)))))

(defun is-correct (update rules)
  (let ((pos (make-hash-table)))
    (loop for page in update
          for i from 0
          do (setf (gethash page pos) i))
    (loop for rule in rules
          for x = (first rule)
          for y = (second rule)
          do (let ((pos-x (gethash x pos))
                   (pos-y (gethash y pos)))
               (when (and pos-x pos-y (> pos-x pos-y))
                 (return-from is-correct nil))))
    t))

(defun correct-order (update rules)
  (let ((pages (make-hash-table))
        (adj (make-hash-table :test 'eql))
        (indeg (make-hash-table :test 'eql)))
    (dolist (page update)
      (setf (gethash page pages) t))
    (dolist (page update)
      (setf (gethash page adj) nil)
      (setf (gethash page indeg) 0))
    (dolist (rule rules)
      (let ((x (first rule))
            (y (second rule)))
        (when (and (gethash x pages) (gethash y pages))
          (push y (gethash x adj))
          (incf (gethash y indeg)))))
    (let ((q nil)
          (out nil))
      (let ((initial-q-elements nil))
        (loop for page in update
              when (= (gethash page indeg) 0)
              do (push page initial-q-elements))
        (setf q initial-q-elements))
      (loop while q
            do (let ((n (pop q)))
                 (push n out)
                 (dolist (nxt (gethash n adj))
                   (decf (gethash nxt indeg))
                   (when (= (gethash nxt indeg) 0)
                     (push nxt q)))))
      (nreverse out))))

(defun main ()
  (multiple-value-bind (rules updates) (read-input "input.txt")
    (let ((incorrect-middle-elements nil))
      (dolist (u updates)
        (when (not (is-correct u rules))
          (let* ((fixed (correct-order u rules))
                 (mid-idx (floor (length fixed) 2)))
            (push (nth mid-idx fixed) incorrect-middle-elements))))
      (print (apply #'+ incorrect-middle-elements)))))

(main)
