
(in-package :cl-user)

(defpackage :rtg-hell-day
  (:use :cl)
  (:import-from :cl-ppcre #:split #:regex-replace)
  (:export #:main))

(in-package :rtg-hell-day)

(declaim (optimize (speed 3) (safety 0) (debug 0)))

(defstruct (halve (:constructor make-halve (is-chip material)))
  (is-chip nil :type boolean)
  (material "" :type string))

(defstruct (state (:constructor make-state (floors elevator-level steps)))
  (floors nil :type (vector list))
  (elevator-level 0 :type fixnum)
  (steps 0 :type fixnum))

(defun combinations (items k)
  (when (zerop k) (return-from combinations (list nil)))
  (when (< (length items) k) (return-from combinations nil))
  (when (null items) (return-from combinations nil))
  (let* ((first (car items))
         (rest (cdr items))
         (combs-with-first (mapcar (lambda (c) (cons first c)) (combinations rest (1- k))))
         (combs-without-first (combinations rest k)))
    (append combs-with-first combs-without-first)))

(defmethod state-valid-p ((s state))
  (loop for floor in (coerce (state-floors s) 'list)
        do (let ((gens-seen (make-hash-table :test 'equal)))
             (loop for half in floor
                   when (not (halve-is-chip half))
                   do (setf (gethash (halve-material half) gens-seen) t))
             (when (> (hash-table-count gens-seen) 0)
               (loop for half in floor
                     when (and (halve-is-chip half)
                               (not (gethash (halve-material half) gens-seen)))
                     do (return-from state-valid-p nil)))))
  t)

(defmethod state-done-p ((s state))
  (loop for i from 0 below (1- (length (state-floors s)))
        unless (null (svref (state-floors s) i))
        do (return-from state-done-p nil))
  t)

(defmethod state-hash-key ((s state))
  (let ((gen-to-index (make-hash-table :test 'equal))
        (chip-to-index (make-hash-table :test 'equal)))
    (loop for fl-index from 0 below (length (state-floors s))
          for floor = (svref (state-floors s) fl-index)
          do (loop for half in floor
                   do (if (halve-is-chip half)
                          (setf (gethash (halve-material half) chip-to-index) fl-index)
                          (setf (gethash (halve-material half) gen-to-index) fl-index))))
    (let ((gen-chip-pairs nil))
      (maphash (lambda (material gen-fl)
                 (let ((chip-fl (gethash material chip-to-index)))
                   (push (list gen-fl chip-fl) gen-chip-pairs)))
               gen-to-index)
      (setf gen-chip-pairs (sort gen-chip-pairs #'(lambda (a b)
                                                      (if (= (car a) (car b))
                                                          (< (cadr a) (cadr b))
                                                          (< (car a) (car b))))))
      (list (state-elevator-level s) gen-chip-pairs))))

(defmethod state-get-movable-perm-indices ((s state))
  (let* ((current-floor (svref (state-floors s) (state-elevator-level s)))
         (indices (loop for i from 0 below (length current-floor) collect i)))
    (append (combinations indices 1) (combinations indices 2))))

(defmethod state-clone ((s state))
  (make-state (map 'vector #'copy-list (state-floors s))
              (state-elevator-level s)
              (state-steps s)))

(defmethod state-get-next-states ((s state))
  (let ((future-states nil)
        (movable-perm-indices (state-get-movable-perm-indices s))
        (num-floors (length (state-floors s)))
        (ele-diffs '(-1 1)))
    (loop for ele-diff in ele-diffs
          for new-elevator-level = (+ (state-elevator-level s) ele-diff)
          when (and (>= new-elevator-level 0) (< new-elevator-level num-floors))
          do (loop for perm-indices in movable-perm-indices
                    do (let* ((cloned-state (state-clone s))
                              (old-level (state-elevator-level s))
                              (new-level new-elevator-level)
                              (source-floor-items (svref (state-floors s) old-level))
                              (dest-floor-items (svref (state-floors s) new-level))
                              (items-to-move nil)
                              (remaining-items-on-old-floor nil))
                         (loop for i from 0 below (length source-floor-items)
                               for item = (nth i source-floor-items)
                               do (if (member i perm-indices)
                                      (push item items-to-move)
                                      (push item remaining-items-on-old-floor)))
                         (setf items-to-move (nreverse items-to-move))
                         (setf remaining-items-on-old-floor (nreverse remaining-items-on-old-floor))

                         (setf (state-elevator-level cloned-state) new-level)
                         (incf (state-steps cloned-state))

                         (setf (svref (state-flopped cloned-state) old-level) remaining-items-on-old-floor)
                         (setf (svref (state-floors cloned-state) new-level) (append dest-floor-items items-to-move))

                         (when (state-valid-p cloned-state)
                           (push cloned-state future-states)))))
    future-states))

(defun read-file (file-path)
  (with-open-file (stream file-path :direction :input)
    (loop for line = (read-line stream nil)
          while line
          collect line)))

(defun rtg-hell-day (input-lines part)
  (let ((floors (make-array 4 :initial-element nil)))
    (loop for line-index from 0 below (length input-lines)
          for line = (nth line-index input-lines)
          do
             (let ((words (split "[\\s,.]+" (string-downcase line) :limit 0 :omit-nulls t)))
               (loop for i from 0 below (length words)
                     for word = (nth i words)
                     do (cond ((string= word "generator")
                               (let ((material (nth (1- i) words)))
                                 (push (make-halve nil material) (svref floors line-index))))
                              ((string= word "microchip")
                               (let* ((full-material-word (nth (1- i) words))
                                      (material (regex-replace "-compatible$" full-material-word "")))
                                 (push (make-halve t material) (svref floors line-index))))))))

    (let ((initial-state (make-state (map 'vector #'copy-list floors) 0 0)))
      (when (= part 2)
        (setf (svref (state-floors initial-state) 0)
              (append (svref (state-floors initial-state) 0)
                      (list (make-halve nil "elerium") (make-halve t "elerium")
                            (make-halve nil "dilithium") (make-halve t "dilithium")))))

      (let ((queue (list initial-state))
            (prev-states (make-hash-table :test 'equal)))
        (loop while queue
              do (let* ((front (pop queue))
                        (hash-key (state-hash-key front)))
                   (when (state-done-p front)
                     (return-from rtg-hell-day (state-steps front)))
                   (unless (gethash hash-key prev-states)
                     (setf (gethash hash-key prev-states) t)
                     (setf queue (append queue (state-get-next-states front)))))))
      -1)))

(defun main ()
  (let* ((input-lines (read-file "input.txt"))
         (result (rtg-hell-day input-lines 2)))
    (format t "~a~%" result)))
