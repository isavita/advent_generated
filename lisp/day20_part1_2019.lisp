
(defun char-in-range (char start end)
  (let ((code (char-code char)))
    (and (>= code (char-code start))
         (<= code (char-code end)))))

(defun read-maze (filename)
  (with-open-file (file filename :direction :input)
    (coerce (loop for line = (read-line file nil nil)
                  while line
                  collect line) 'vector)))

(defun find-portals (maze)
  (let* ((height (length maze))
         (width (length (aref maze 0)))
         (portals (make-hash-table :test 'equal))
         (portal-positions (make-hash-table :test 'equal)))
    (dotimes (y height)
      (dotimes (x width)
        (let ((char1 (char (aref maze y) x)))
          (when (char-in-range char1 #\A #\Z)
            (when (and (< (+ x 1) width)
                       (char-in-range (char (aref maze y) (+ x 1)) #\A #\Z))
              (let* ((char2 (char (aref maze y) (+ x 1)))
                     (portal-name (string-upcase (concatenate 'string (string char1) (string char2)))))
                (cond
                  ((and (< (+ x 2) width) (char= (char (aref maze y) (+ x 2)) #\.))
                   (let ((pos (list (+ x 2) y)))
                     (push pos (gethash portal-name portals nil))
                     (setf (gethash pos portal-positions) portal-name)))
                  ((and (>= (- x 1) 0) (char= (char (aref maze y) (- x 1)) #\.))
                   (let ((pos (list (- x 1) y)))
                     (push pos (gethash portal-name portals nil))
                     (setf (gethash pos portal-positions) portal-name))))))
            (when (and (< (+ y 1) height)
                       (char-in-range (char (aref maze (+ y 1)) x) #\A #\Z))
              (let* ((char2 (char (aref maze (+ y 1)) x))
                     (portal-name (string-upcase (concatenate 'string (string char1) (string char2)))))
                (cond
                  ((and (< (+ y 2) height) (char= (char (aref maze (+ y 2)) x) #\.))
                   (let ((pos (list x (+ y 2))))
                     (push pos (gethash portal-name portals nil))
                     (setf (gethash pos portal-positions) portal-name)))
                  ((and (>= (- y 1) 0) (char= (char (aref maze (- y 1)) x) #\.))
                   (let ((pos (list x (- y 1))))
                     (push pos (gethash portal-name portals nil))
                     (setf (gethash pos portal-positions) portal-name))))))))))
    (values portals portal-positions)))

(defun bfs (maze portals portal-positions start end)
  (let* ((height (length maze))
         (width (length (aref maze 0)))
         (q-head nil)
         (q-tail nil)
         (visited (make-hash-table :test 'equal)))
    (labels ((q-empty-p () (null q-head))
             (q-push (item)
               (if (null q-head)
                   (setf q-head (setf q-tail (list item)))
                   (setf (cdr q-tail) (list item)
                         q-tail (cdr q-tail))))
             (q-pop ()
               (when q-head
                 (prog1 (car q-head)
                   (setf q-head (cdr q-head))))))
      (q-push (list (car start) (cadr start) 0))
      (setf (gethash start visited) t)
      (loop while (not (q-empty-p))
            do (let* ((current (q-pop))
                      (x (car current))
                      (y (cadr current))
                      (steps (caddr current)))
                 (dolist (dir '((-1 0) (1 0) (0 -1) (0 1)))
                   (let* ((dx (car dir))
                          (dy (cadr dir))
                          (nx (+ x dx))
                          (ny (+ y dy))
                          (next-pos (list nx ny)))
                     (when (and (>= nx 0) (< nx width)
                                (>= ny 0) (< ny height)
                                (char= (char (aref maze ny) nx) #\.))
                       (when (equal next-pos end)
                         (return-from bfs (+ steps 1)))
                       (unless (gethash next-pos visited)
                         (setf (gethash next-pos visited) t)
                         (q-push (list nx ny (+ steps 1)))))))
                 (let ((portal-name (gethash (list x y) portal-positions)))
                   (when portal-name
                     (dolist (pxpy (gethash portal-name portals))
                       (when (and (not (equal pxpy (list x y)))
                                  (not (gethash pxpy visited)))
                         (setf (gethash pxpy visited) t)
                         (q-push (list (car pxpy) (cadr pxpy) (+ steps 1))))))))))
    -1))

(defun main ()
  (let* ((maze (read-maze "input.txt"))
         (portals nil)
         (portal-positions nil))
    (multiple-value-setq (portals portal-positions) (find-portals maze))
    (let* ((start (car (gethash "AA" portals)))
           (end (car (gethash "ZZ" portals)))
           (result (bfs maze portals portal-positions start end)))
      (format t "~a~%" result))))

(main)
