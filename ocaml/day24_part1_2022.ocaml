
let rec gcd a b = if b = 0 then a else gcd b (a mod b)
let lcm a b = if a = 0 || b = 0 then 0 else (a / gcd a b) * b

let () =
  let grid =
    let ic = open_in "input.txt" in
    let rec loop acc =
      match input_line ic with
      | s -> if String.length s > 0 then loop (s :: acc) else loop acc
      | exception End_of_file -> close_in ic; List.rev acc
    in
    Array.of_list (loop [])
  in
  if Array.length grid > 0 then
    let rows, cols = Array.length grid, String.length grid.(0) in
    let ir, ic = rows - 2, cols - 2 in
    let period = lcm ir ic in
    let has_blizzard r c t =
      if r < 1 || r > ir || c < 1 || c > ic then false
      else
        let t_ic, t_ir = t mod ic, t mod ir in
        grid.(r).[((c - 1 - t_ic + ic) mod ic) + 1] = '>' ||
        grid.(r).[((c - 1 + t_ic) mod ic) + 1] = '<' ||
        grid.((r - 1 - t_ir + ir) mod ir + 1).[c] = 'v' ||
        grid.((r - 1 + t_ir) mod ir + 1).[c] = '^'
    in
    let layer_size = rows * cols in
    let visited = Bytes.make (period * layer_size) '\000' in
    let q = Queue.create () in
    let target_r, target_c = rows - 1, cols - 2 in
    
    Queue.push (0, 1, 0) q;
    Bytes.set visited (0 * layer_size + 0 * cols + 1) '\001';
    
    let ans = ref (-1) in
    let moves = [(0, 0); (1, 0); (-1, 0); (0, 1); (0, -1)] in
    
    while not (Queue.is_empty q) && !ans = -1 do
      let r, c, t = Queue.pop q in
      if r = target_r && c = target_c then
        ans := t
      else
        let nt = t + 1 in
        let mt = nt mod period in
        List.iter (fun (dr, dc) ->
          let nr, nc = r + dr, c + dc in
          if nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
             grid.(nr).[nc] <> '#' && not (has_blizzard nr nc nt) then
            let idx = mt * layer_size + nr * cols + nc in
            if Bytes.get visited idx = '\000' then (
              Bytes.set visited idx '\001';
              Queue.push (nr, nc, nt) q
            )
        ) moves
    done;
    Printf.printf "%d\n" !ans

