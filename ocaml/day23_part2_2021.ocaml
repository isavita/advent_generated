
module MinHeap = struct
  type 'a t = {
    mutable size : int;
    data : 'a array;
    comp : 'a -> 'a -> int;
  }
  let create capacity dummy comp = { size = 0; data = Array.make capacity dummy; comp }
  let push h x =
    let i = ref h.size in
    h.size <- h.size + 1;
    while !i > 0 && h.comp x h.data.((!i - 1) / 2) < 0 do
      h.data.(!i) <- h.data.((!i - 1) / 2);
      i := (!i - 1) / 2
    done;
    h.data.(!i) <- x
  let pop h =
    let res = h.data.(0) in
    h.size <- h.size - 1;
    if h.size > 0 then (
      let x = h.data.(h.size) in
      let i = ref 0 in
      let stop = ref false in
      while !i * 2 + 1 < h.size && not !stop do
        let j = ref (!i * 2 + 1) in
        if !j + 1 < h.size && h.comp h.data.(!j + 1) h.data.(!j) < 0 then j := !j + 1;
        if h.comp x h.data.(!j) <= 0 then stop := true
        else ( h.data.(!i) <- h.data.(!j); i := !j )
      done;
      h.data.(!i) <- x
    );
    res
  let is_empty h = h.size = 0
end

let char_to_room_idx = function 'A' -> 0 | 'B' -> 1 | 'C' -> 2 | 'D' -> 3 | _ -> -1
let room_to_char = [| 'A'; 'B'; 'C'; 'D' |]
let energy_map = function 'A' -> 1 | 'B' -> 10 | 'C' -> 100 | 'D' -> 1000 | _ -> 0
let entrance_h_idx = [| 2; 4; 6; 8 |]
let hallway_stops = [0; 1; 3; 5; 7; 9; 10]
let room_pos ri depth = 11 + ri * 4 + depth

let can_enter_room ri state c =
  let possible = ref true in
  for d = 0 to 3 do
    let cell = state.[room_pos ri d] in
    if cell <> '.' && cell <> c then possible := false
  done;
  !possible

let get_deepest_empty_spot ri state =
  let deepest = ref (-1) in
  for d = 0 to 3 do if state.[room_pos ri d] = '.' then deepest := d done;
  !deepest

let get_top_amphipod ri state =
  let res = ref None in
  let found = ref false in
  for d = 0 to 3 do
    if not !found then
      let cell = state.[room_pos ri d] in
      if cell <> '.' then ( res := Some (d, cell); found := true )
  done;
  !res

let needs_to_move ri depth state =
  let c = state.[room_pos ri depth] in
  if c <> room_to_char.(ri) then true
  else
    let must_move = ref false in
    for d = depth + 1 to 3 do
      if state.[room_pos ri d] <> room_to_char.(ri) then must_move := true
    done;
    !must_move

let hallway_path_clear h1 h2 state =
  let s, e = if h1 < h2 then h1 + 1, h2 else h2, h1 - 1 in
  let clear = ref true in
  for i = s to e do if state.[i] <> '.' then clear := false done;
  !clear

let get_moves state =
  let moves = ref [] in
  for hi = 0 to 10 do
    let c = state.[hi] in
    if c <> '.' then
      let ri = char_to_room_idx c in
      let entrance = entrance_h_idx.(ri) in
      if can_enter_room ri state c && hallway_path_clear hi entrance state then
        let depth = get_deepest_empty_spot ri state in
        let move_cost = (abs (hi - entrance) + depth + 1) * energy_map c in
        let next_s = Bytes.of_string state in
        Bytes.set next_s hi '.'; Bytes.set next_s (room_pos ri depth) c;
        moves := (Bytes.to_string next_s, move_cost) :: !moves
  done;
  for ri = 0 to 3 do
    match get_top_amphipod ri state with
    | Some (depth, c) ->
      if needs_to_move ri depth state then
        let entrance = entrance_h_idx.(ri) in
        List.iter (fun hi ->
          if hallway_path_clear entrance hi state then
            let move_cost = (abs (hi - entrance) + depth + 1) * energy_map c in
            let next_s = Bytes.of_string state in
            Bytes.set next_s (room_pos ri depth) '.'; Bytes.set next_s hi c;
            moves := (Bytes.to_string next_s, move_cost) :: !moves
        ) hallway_stops
    | None -> ()
  done;
  !moves

let get_initial_state () =
  let ch = open_in "input.txt" in
  let rec read_lines acc = try read_lines (input_line ch :: acc) with _ -> close_in ch; List.rev acc in
  let lines = read_lines [] in
  let l2, l3 = List.nth lines 2, List.nth lines 3 in
  let s = Bytes.make 27 '.' in
  Bytes.set s 11 l2.[3]; Bytes.set s 15 l2.[5]; Bytes.set s 19 l2.[7]; Bytes.set s 23 l2.[9];
  Bytes.set s 12 'D'; Bytes.set s 16 'C'; Bytes.set s 20 'B'; Bytes.set s 24 'A';
  Bytes.set s 13 'D'; Bytes.set s 17 'B'; Bytes.set s 21 'A'; Bytes.set s 25 'C';
  Bytes.set s 14 l3.[3]; Bytes.set s 18 l3.[5]; Bytes.set s 22 l3.[7]; Bytes.set s 26 l3.[9];
  Bytes.to_string s

let solve () =
  let initial = get_initial_state () in
  let goal =
    let s = Bytes.make 27 '.' in
    for ri = 0 to 3 do for d = 0 to 3 do Bytes.set s (room_pos ri d) room_to_char.(ri) done done;
    Bytes.to_string s in
  let pq = MinHeap.create 1000000 (0, "") (fun (d1, _) (d2, _) -> compare d1 d2) in
  let dists = Hashtbl.create 100000 in
  MinHeap.push pq (0, initial); Hashtbl.add dists initial 0;
  let result = ref (-1) in
  while not (MinHeap.is_empty pq) && !result = -1 do
    let (d, s) = MinHeap.pop pq in
    if d = Hashtbl.find dists s then
      if s = goal then result := d
      else List.iter (fun (s_new, move_cost) ->
        let d_new = d + move_cost in
        let old_d = try Hashtbl.find dists s_new with Not_found -> max_int in
        if d_new < old_d then ( Hashtbl.replace dists s_new d_new; MinHeap.push pq (d_new, s_new) )
      ) (get_moves s)
  done;
  !result

let () = Printf.printf "%d\n" (solve ())

