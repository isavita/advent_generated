
type machine = {
  mem : (int, int) Hashtbl.t;
  mutable ip : int;
  mutable rb : int;
}

let get_mem h k = match Hashtbl.find_opt h k with Some v -> v | None -> 0

let get_val m addr mode =
  let v = get_mem m.mem addr in
  match mode with
  | 0 -> get_mem m.mem v
  | 1 -> v
  | 2 -> get_mem m.mem (m.rb + v)
  | _ -> 0

let set_val m addr mode v =
  let p = get_mem m.mem addr in
  let target = if mode = 2 then m.rb + p else p in
  Hashtbl.replace m.mem target v

let run m input =
  let res = ref None in
  while !res = None do
    let instr = get_mem m.mem m.ip in
    let op = instr mod 100 in
    let mode i = (instr / (match i with 1 -> 100 | 2 -> 1000 | 3 -> 10000 | _ -> 1)) mod 10 in
    match op with
    | 1 ->
        set_val m (m.ip + 3) (mode 3) (get_val m (m.ip + 1) (mode 1) + get_val m (m.ip + 2) (mode 2));
        m.ip <- m.ip + 4
    | 2 ->
        set_val m (m.ip + 3) (mode 3) (get_val m (m.ip + 1) (mode 1) * get_val m (m.ip + 2) (mode 2));
        m.ip <- m.ip + 4
    | 3 ->
        set_val m (m.ip + 1) (mode 1) input;
        m.ip <- m.ip + 2
    | 4 ->
        res := Some (get_val m (m.ip + 1) (mode 1));
        m.ip <- m.ip + 2
    | 5 ->
        if get_val m (m.ip + 1) (mode 1) <> 0 then m.ip <- get_val m (m.ip + 2) (mode 2)
        else m.ip <- m.ip + 3
    | 6 ->
        if get_val m (m.ip + 1) (mode 1) = 0 then m.ip <- get_val m (m.ip + 2) (mode 2)
        else m.ip <- m.ip + 3
    | 7 ->
        set_val m (m.ip + 3) (mode 3) (if get_val m (m.ip + 1) (mode 1) < get_val m (m.ip + 2) (mode 2) then 1 else 0);
        m.ip <- m.ip + 4
    | 8 ->
        set_val m (m.ip + 3) (mode 3) (if get_val m (m.ip + 1) (mode 1) = get_val m (m.ip + 2) (mode 2) then 1 else 0);
        m.ip <- m.ip + 4
    | 9 ->
        m.rb <- m.rb + get_val m (m.ip + 1) (mode 1);
        m.ip <- m.ip + 2
    | 99 -> failwith "Halt"
    | _ -> failwith "Unknown op"
  done;
  match !res with Some v -> v | None -> failwith "No output"

let grid = Hashtbl.create 2048
let oxygen_pos = ref (0, 0)

let rec explore m x y =
  let dirs = [ (1, (0, 1), 2); (2, (0, -1), 1); (3, (-1, 0), 4); (4, (1, 0), 3) ] in
  List.iter
    (fun (d, (dx, dy), rev_d) ->
      let nx, ny = (x + dx, y + dy) in
      if not (Hashtbl.mem grid (nx, ny)) then
        let res = run m d in
        Hashtbl.add grid (nx, ny) res;
        if res <> 0 then (
          if res = 2 then oxygen_pos := (nx, ny);
          explore m nx ny;
          ignore (run m rev_d)))
    dirs

let bfs start_pos grid =
  let q = Queue.create () in
  let dists = Hashtbl.create 2048 in
  Queue.push (start_pos, 0) q;
  Hashtbl.add dists start_pos 0;
  let max_d = ref 0 in
  while not (Queue.is_empty q) do
    let (x, y), d = Queue.take q in
    if d > !max_d then max_d := d;
    List.iter
      (fun (dx, dy) ->
        let np = (x + dx, y + dy) in
        match Hashtbl.find_opt grid np with
        | Some status when status <> 0 && not (Hashtbl.mem dists np) ->
            Hashtbl.add dists np (d + 1);
            Queue.push (np, d + 1) q
        | _ -> ())
      [ (0, 1); (0, -1); (1, 0); (-1, 0) ]
  done;
  !max_d

let main () =
  let ic = open_in "input.txt" in
  let content = really_input_string ic (in_channel_length ic) in
  close_in ic;
  let program =
    String.split_on_char ',' (String.trim content)
    |> List.filter (fun s -> String.length s > 0)
    |> List.map int_of_string
  in
  let m = { mem = Hashtbl.create 2048; ip = 0; rb = 0 } in
  List.iteri (fun i v -> Hashtbl.add m.mem i v) program;
  Hashtbl.add grid (0, 0) 1;
  explore m 0 0;
  let ans = bfs !oxygen_pos grid in
  Printf.printf "%d\n" ans

let () = main ()
