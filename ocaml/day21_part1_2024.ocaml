
(* OCaml implementation of the described algorithm *)

type position = int * int

let find_position mat rows cols ch =
  let rec aux i =
    if i = rows then (-1, -1)
    else
      let row = mat.(i) in
      let rec find_j j =
        if j = cols then (-1, -1)
        else if row.[j] = ch then (i, j)
        else find_j (j + 1)
      in
      let pos = find_j 0 in
      if fst pos <> -1 then pos else aux (i + 1)
  in
  aux 0

let ok mat rows cols (i, j) seq =
  let rec aux (ci, cj) idx =
    if idx = String.length seq then true
    else
      if mat.(ci).[cj] = ' ' then false
      else
        let ci', cj' =
          match seq.[idx] with
          | '^' -> (ci - 1, cj)
          | 'v' -> (ci + 1, cj)
          | '<' -> (ci, cj - 1)
          | '>' -> (ci, cj + 1)
          | _   -> (ci, cj)
        in
        if ci' < 0 || ci' >= rows || cj' < 0 || cj' >= cols then false
        else aux (ci', cj') (idx + 1)
  in
  aux (i, j) 0

let generate_moves pos objective pad rows cols =
  let obj_pos = find_position pad rows cols objective in
  let buf = Buffer.create 32 in
  let (pi, pj) = pos in
  let (oi, oj) = obj_pos in
  (* first order *)
  for _ = 0 to pj - oj - 1 do Buffer.add_char buf '<' done;
  for _ = 0 to pi - oi - 1 do Buffer.add_char buf '^' done;
  for _ = 0 to oi - pi - 1 do Buffer.add_char buf 'v' done;
  for _ = 0 to oj - pj - 1 do Buffer.add_char buf '>' done;
  let moves = Buffer.contents buf in
  if ok pad rows cols pos moves then moves
  else
    (* second order *)
    let buf2 = Buffer.create 32 in
    for _ = 0 to oj - pj - 1 do Buffer.add_char buf2 '>' done;
    for _ = 0 to pi - oi - 1 do Buffer.add_char buf2 '^' done;
    for _ = 0 to oi - pi - 1 do Buffer.add_char buf2 'v' done;
    for _ = 0 to pj - oj - 1 do Buffer.add_char buf2 '<' done;
    Buffer.contents buf2

let rec solve code robots key_pad kp_rows kp_cols robot_pad rp_rows rp_cols max_robots =
  if robots <= 0 then String.length code
  else
    let posi = if robots = max_robots then 3 else 0 in
    let posj = 2 in
    let rec aux i (posi, posj) acc =
      if i = String.length code then acc
      else
        let ch = code.[i] in
        let pad, rows, cols =
          if robots = max_robots then (key_pad, kp_rows, kp_cols)
          else (robot_pad, rp_rows, rp_cols)
        in
        let moves = generate_moves (posi, posj) ch pad rows cols in
        let new_pos = find_position pad rows cols ch in
        let new_code = moves ^ "A" in
        let sub = solve new_code (robots - 1) key_pad kp_rows kp_cols robot_pad rp_rows rp_cols max_robots in
        aux (i + 1) new_pos (acc + sub)
    in
    aux 0 (posi, posj) 0

let () =
  let max_robots = 3 in
  let key_pad = [|
    "789";
    "456";
    "123";
    " 0A"
  |] in
  let kp_rows = Array.length key_pad in
  let kp_cols = String.length key_pad.(0) in
  let robot_pad = [|
    " ^A";
    "<v>"
  |] in
  let rp_rows = Array.length robot_pad in
  let rp_cols = String.length robot_pad.(0) in
  let ic = open_in "input.txt" in
  let rec read_lines acc =
    try
      let line = input_line ic in
      read_lines (line :: acc)
    with End_of_file -> List.rev acc
  in
  let lines = read_lines [] in
  close_in ic;
  let total =
    List.fold_left (fun acc line ->
      let code = String.trim line in
      if code = "" then acc
      else
        let numeric_part =
          String.fold_left (fun n c ->
            if '0' <= c && c <= '9' then n * 10 + (int_of_char c - int_of_char '0')
            else n) 0 code
        in
        let sv = solve code max_robots key_pad kp_rows kp_cols robot_pad rp_rows rp_cols max_robots in
        acc + sv * numeric_part
    ) 0 lines
  in
  Printf.printf "%d\n" total
