
IDENTIFICATION DIVISION.
PROGRAM-ID. ROBOT-SIMULATOR.

ENVIRONMENT DIVISION.
INPUT-OUTPUT SECTION.
FILE-CONTROL.
    SELECT INPUT-FILE ASSIGN TO "input.txt"
        ORGANIZATION IS LINE SEQUENTIAL.

DATA DIVISION.
FILE SECTION.
FD INPUT-FILE.
01 INPUT-RECORD PIC X(256).

WORKING-STORAGE SECTION.
*> Constants
77 WS-SIZE-X PIC 9(3) VALUE 101.
77 WS-SIZE-Y PIC 9(3) VALUE 103.
77 WS-MAX-ROBOTS PIC 9(4) VALUE 1000. *> Max number of robots
77 WS-MAX-ITERATIONS PIC 9(7) VALUE 1000000.

*> File I/O
77 WS-FILE-STATUS PIC X(2) VALUE "00".
77 WS-EOF-FLAG PIC X(1) VALUE 'N'.

*> Robot Data Structure (Original)
01 WS-ROBOT-TABLE.
   05 WS-ROBOT OCCURS 1000 TIMES INDEXED BY ROBOT-IDX.
      10 WS-ROBOT-X PIC S9(4) COMP-5.
      10 WS-ROBOT-Y PIC S9(4) COMP-5.
      10 WS-ROBOT-VX PIC S9(4) COMP-5.
      10 WS-ROBOT-VY PIC S9(4) COMP-5.
01 WS-NUM-ROBOTS PIC 9(4) VALUE 0.

*> Robot Data Structure for Part 1 (Copy)
01 WS-ROBOT-TABLE-P1.
   05 WS-ROBOT-P1 OCCURS 1000 TIMES INDEXED BY ROBOT-P1-IDX.
      10 WS-ROBOT-P1-X PIC S9(4) COMP-5.
      10 WS-ROBOT-P1-Y PIC S9(4) COMP-5.
      10 WS-ROBOT-P1-VX PIC S9(4) COMP-5.
      10 WS-ROBOT-P1-VY PIC S9(4) COMP-5.

*> Robot Data Structure for Part 2 (Copy)
01 WS-ROBOT-TABLE-P2.
   05 WS-ROBOT-P2 OCCURS 1000 TIMES INDEXED BY ROBOT-P2-IDX.
      10 WS-ROBOT-P2-X PIC S9(4) COMP-5.
      10 WS-ROBOT-P2-Y PIC S9(4) COMP-5.
      10 WS-ROBOT-P2-VX PIC S9(4) COMP-5.
      10 WS-ROBOT-P2-VY PIC S9(4) COMP-5.

*> Parsing variables
01 WS-INPUT-LINE PIC X(256).
01 WS-TEMP-FIELD-P PIC X(10). *> For 'p' prefix
01 WS-TEMP-FIELD-X PIC X(10).
01 WS-TEMP-FIELD-Y PIC X(10).
01 WS-TEMP-FIELD-VX PIC X(10).
01 WS-TEMP-FIELD-VY PIC X(10).
01 WS-UNSTRING-PTR PIC 9(3).

*> Modulo variables
77 WS-MOD-A PIC S9(9) COMP-5.
77 WS-MOD-B PIC S9(9) COMP-5.
77 WS-MOD-RESULT PIC S9(9) COMP-5.

*> Quadrant counts
01 WS-QUADRANT-COUNTS.
   05 WS-Q-COUNT OCCURS 4 TIMES PIC 9(5) VALUE 0.
77 WS-CENTER-X PIC 9(3).
77 WS-CENTER-Y PIC 9(3).
77 WS-SAFETY-FACTOR PIC 9(18) VALUE 1.

*> Overlap check grid
01 WS-OCCUPIED-GRID.
   05 WS-OCCUPIED-ROW OCCURS 103 TIMES.
      10 WS-OCCUPIED-CELL OCCURS 101 TIMES PIC X(1).
77 WS-OVERLAP-FOUND PIC X(1) VALUE 'N'. *> 'Y' for true (no overlap), 'N' for false (overlap)

*> Drawing grid
01 WS-DISPLAY-GRID.
   05 WS-DISPLAY-ROW OCCURS 103 TIMES.
      10 WS-DISPLAY-CELL OCCURS 101 TIMES PIC X(1).

*> Loop counters
77 WS-LOOP-I PIC 9(5).
77 WS-SECONDS PIC 9(7) VALUE 0.

PROCEDURE DIVISION.

MAIN-LOGIC SECTION.
    PERFORM 000-INITIALIZE.
    PERFORM 100-READ-INPUT.
    PERFORM 200-PART1-LOGIC.
    PERFORM 300-PART2-LOGIC.
    PERFORM 900-CLEANUP.
    STOP RUN.

000-INITIALIZE SECTION.
    COMPUTE WS-CENTER-X = WS-SIZE-X / 2.
    COMPUTE WS-CENTER-Y = WS-SIZE-Y / 2.
    .

100-READ-INPUT SECTION.
    OPEN INPUT INPUT-FILE.
    IF WS-FILE-STATUS NOT = "00"
        DISPLAY "Error opening input.txt: " WS-FILE-STATUS
        STOP RUN
    END-IF.

    PERFORM UNTIL WS-EOF-FLAG = 'Y'
        READ INPUT-FILE INTO WS-INPUT-LINE
            AT END
                MOVE 'Y' TO WS-EOF-FLAG
            NOT AT END
                IF WS-INPUT-LINE NOT = SPACES
                    PERFORM 110-PARSE-LINE
                END-IF
        END-READ
    END-PERFORM.
    CLOSE INPUT-FILE.
    .

110-PARSE-LINE SECTION.
    *> Example line format: p=10,20 v=-5,3
    *> Delimiters: '=', ',', ' v=' (note the space before 'v')
    MOVE 1 TO WS-UNSTRING-PTR.
    UNSTRING WS-INPUT-LINE
        DELIMITED BY '=' OR ',' OR ' v='
        INTO WS-TEMP-FIELD-P *> 'p'
             WS-TEMP-FIELD-X
             WS-TEMP-FIELD-Y
             WS-TEMP-FIELD-VX
             WS-TEMP-FIELD-VY
        WITH POINTER WS-UNSTRING-PTR
        ON OVERFLOW
            DISPLAY "Error parsing line: " WS-INPUT-LINE
            STOP RUN
    END-UNSTRING.

    ADD 1 TO WS-NUM-ROBOTS.
    IF WS-NUM-ROBOTS > WS-MAX-ROBOTS
        DISPLAY "Exceeded max robots: " WS-MAX-ROBOTS
        STOP RUN
    END-IF.

    SET ROBOT-IDX TO WS-NUM-ROBOTS.
    MOVE FUNCTION NUMVAL(WS-TEMP-FIELD-X) TO WS-ROBOT-X(ROBOT-IDX).
    MOVE FUNCTION NUMVAL(WS-TEMP-FIELD-Y) TO WS-ROBOT-Y(ROBOT-IDX).
    MOVE FUNCTION NUMVAL(WS-TEMP-FIELD-VX) TO WS-ROBOT-VX(ROBOT-IDX).
    MOVE FUNCTION NUMVAL(WS-TEMP-FIELD-VY) TO WS-ROBOT-VY(ROBOT-IDX).
    .

200-PART1-LOGIC SECTION.
    *> Copy initial robots to P1 table
    PERFORM VARYING ROBOT-IDX FROM 1 BY 1 UNTIL ROBOT-IDX > WS-NUM-ROBOTS
        SET ROBOT-P1-IDX TO ROBOT-IDX
        MOVE WS-ROBOT(ROBOT-IDX) TO WS-ROBOT-P1(ROBOT-P1-IDX)
    END-PERFORM.

    PERFORM VARYING WS-LOOP-I FROM 1 BY 1 UNTIL WS-LOOP-I > 100
        PERFORM 210-MOVE-ROBOTS-P1
    END-PERFORM.

    PERFORM 220-COUNT-QUADRANTS-P1.

    MOVE 1 TO WS-SAFETY-FACTOR.
    PERFORM VARYING WS-LOOP-I FROM 1 BY 1 UNTIL WS-LOOP-I > 4
        COMPUTE WS-SAFETY-FACTOR = WS-SAFETY-FACTOR * WS-Q-COUNT(WS-LOOP-I)
    END-PERFORM.

    DISPLAY "Part 1 - Safety Factor after 100 seconds: " WS-SAFETY-FACTOR.
    .

210-MOVE-ROBOTS-P1 SECTION.
    PERFORM VARYING ROBOT-P1-IDX FROM 1 BY 1 UNTIL ROBOT-P1-IDX > WS-NUM-ROBOTS
        COMPUTE WS-MOD-A = WS-ROBOT-P1-X(ROBOT-P1-IDX) + WS-ROBOT-P1-VX(ROBOT-P1-IDX)
        MOVE WS-SIZE-X TO WS-MOD-B
        PERFORM 400-MOD-CALC
        MOVE WS-MOD-RESULT TO WS-ROBOT-P1-X(ROBOT-P1-IDX)

        COMPUTE WS-MOD-A = WS-ROBOT-P1-Y(ROBOT-P1-IDX) + WS-ROBOT-P1-VY(ROBOT-P1-IDX)
        MOVE WS-SIZE-Y TO WS-MOD-B
        PERFORM 400-MOD-CALC
        MOVE WS-MOD-RESULT TO WS-ROBOT-P1-Y(ROBOT-P1-IDX)
    END-PERFORM.
    .

220-COUNT-QUADRANTS-P1 SECTION.
    MOVE 0 TO WS-Q-COUNT(1) WS-Q-COUNT(2) WS-Q-COUNT(3) WS-Q-COUNT(4).
    PERFORM VARYING ROBOT-P1-IDX FROM 1 BY 1 UNTIL ROBOT-P1-IDX > WS-NUM-ROBOTS
        IF WS-ROBOT-P1-X(ROBOT-P1-IDX) < WS-CENTER-X
            IF WS-ROBOT-P1-Y(ROBOT-P1-IDX) < WS-CENTER-Y
                ADD 1 TO WS-Q-COUNT(1)
            ELSE IF WS-ROBOT-P1-Y(ROBOT-P1-IDX) > WS-CENTER-Y
                ADD 1 TO WS-Q-COUNT(2)
            END-IF
        ELSE IF WS-ROBOT-P1-X(ROBOT-P1-IDX) > WS-CENTER-X
            IF WS-ROBOT-P1-Y(ROBOT-P1-IDX) < WS-CENTER-Y
                ADD 1 TO WS-Q-COUNT(3)
            ELSE IF WS-ROBOT-P1-Y(ROBOT-P1-IDX) > WS-CENTER-Y
                ADD 1 TO WS-Q-COUNT(4)
            END-IF
        END-IF
    END-PERFORM.
    .

300-PART2-LOGIC SECTION.
    *> Copy initial robots to P2 table
    PERFORM VARYING ROBOT-IDX FROM 1 BY 1 UNTIL ROBOT-IDX > WS-NUM-ROBOTS
        SET ROBOT-P2-IDX TO ROBOT-IDX
        MOVE WS-ROBOT(ROBOT-IDX) TO WS-ROBOT-P2(ROBOT-P2-IDX)
    END-PERFORM.

    MOVE 0 TO WS-SECONDS.
    PERFORM UNTIL WS-OVERLAP-FOUND = 'Y' OR WS-SECONDS > WS-MAX-ITERATIONS
        PERFORM 310-HAS-NO-OVERLAPS-P2
        IF WS-OVERLAP-FOUND = 'Y'
            EXIT PERFORM
        END-IF
        PERFORM 320-MOVE-ROBOTS-P2
        ADD 1 TO WS-SECONDS
    END-PERFORM.

    IF WS-SECONDS > WS-MAX-ITERATIONS
        DISPLAY "Exceeded maximum iterations without finding a unique position configuration."
    ELSE
        DISPLAY "Part 2 - Fewest seconds to display Easter egg: " WS-SECONDS
        DISPLAY "Final positions of robots:"
        PERFORM 330-DRAW-GRID-P2
    END-IF.
    .

310-HAS-NO-OVERLAPS-P2 SECTION.
    MOVE 'Y' TO WS-OVERLAP-FOUND. *> Assume no overlap initially
    MOVE SPACES TO WS-OCCUPIED-GRID. *> Clear the grid

    PERFORM VARYING ROBOT-P2-IDX FROM 1 BY 1 UNTIL ROBOT-P2-IDX > WS-NUM-ROBOTS
        *> COBOL arrays are 1-indexed, so add 1 to X and Y for grid access
        IF WS-OCCUPIED-CELL(WS-ROBOT-P2-Y(ROBOT-P2-IDX) + 1, WS-ROBOT-P2-X(ROBOT-P2-IDX) + 1) = '#'
            MOVE 'N' TO WS-OVERLAP-FOUND *> Overlap found
            EXIT PERFORM
        ELSE
            MOVE '#' TO WS-OCCUPIED-CELL(WS-ROBOT-P2-Y(ROBOT-P2-IDX) + 1, WS-ROBOT-P2-X(ROBOT-P2-IDX) + 1)
        END-IF
    END-PERFORM.
    .

320-MOVE-ROBOTS-P2 SECTION.
    PERFORM VARYING ROBOT-P2-IDX FROM 1 BY 1 UNTIL ROBOT-P2-IDX > WS-NUM-ROBOTS
        COMPUTE WS-MOD-A = WS-ROBOT-P2-X(ROBOT-P2-IDX) + WS-ROBOT-P2-VX(ROBOT-P2-IDX)
        MOVE WS-SIZE-X TO WS-MOD-B
        PERFORM 400-MOD-CALC
        MOVE WS-MOD-RESULT TO WS-ROBOT-P2-X(ROBOT-P2-IDX)

        COMPUTE WS-MOD-A = WS-ROBOT-P2-Y(ROBOT-P2-IDX) + WS-ROBOT-P2-VY(ROBOT-P2-IDX)
        MOVE WS-SIZE-Y TO WS-MOD-B
        PERFORM 400-MOD-CALC
        MOVE WS-MOD-RESULT TO WS-ROBOT-P2-Y(ROBOT-P2-IDX)
    END-PERFORM.
    .

330-DRAW-GRID-P2 SECTION.
    MOVE '.' TO WS-DISPLAY-GRID. *> Initialize grid with '.'

    PERFORM VARYING ROBOT-P2-IDX FROM 1 BY 1 UNTIL ROBOT-P2-IDX > WS-NUM-ROBOTS
        *> COBOL arrays are 1-indexed, so add 1 to X and Y for grid access
        MOVE '#' TO WS-DISPLAY-CELL(WS-ROBOT-P2-Y(ROBOT-P2-IDX) + 1, WS-ROBOT-P2-X(ROBOT-P2-IDX) + 1)
    END-PERFORM.

    PERFORM VARYING WS-LOOP-I FROM 1 BY 1 UNTIL WS-LOOP-I > WS-SIZE-Y
        DISPLAY WS-DISPLAY-ROW(WS-LOOP-I)
    END-PERFORM.
    .

400-MOD-CALC SECTION.
    COMPUTE WS-MOD-RESULT = FUNCTION REM(WS-MOD-A, WS-MOD-B).
    IF WS-MOD-RESULT < 0
        COMPUTE WS-MOD-RESULT = WS-MOD-RESULT + WS-MOD-B
    END-IF.
    .

900-CLEANUP SECTION.
    *> No specific cleanup needed for this program.
    .

END PROGRAM ROBOT-SIMULATOR.
